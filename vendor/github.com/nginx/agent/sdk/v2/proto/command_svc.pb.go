// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: command_svc.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("command_svc.proto", fileDescriptor_8c55e2f87354005f) }

var fileDescriptor_8c55e2f87354005f = []byte{
	// 226 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4c, 0xce, 0xcf, 0xcd,
	0x4d, 0xcc, 0x4b, 0x89, 0x2f, 0x2e, 0x4b, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x4a,
	0x33, 0xd5, 0xcb, 0x4b, 0xcf, 0xcc, 0xab, 0xd0, 0x4b, 0x4c, 0x4f, 0xcd, 0x2b, 0xd1, 0x2b, 0x4e,
	0xc9, 0x96, 0xe2, 0x85, 0x2a, 0x83, 0x28, 0x31, 0x6a, 0x60, 0xe2, 0xe2, 0x74, 0x86, 0x88, 0xa4,
	0x16, 0x09, 0x05, 0x70, 0xf1, 0x41, 0x39, 0xce, 0x19, 0x89, 0x79, 0x79, 0xa9, 0x39, 0x42, 0xd2,
	0x7a, 0x98, 0x66, 0xe8, 0x41, 0xd5, 0x48, 0xe1, 0x93, 0x54, 0x62, 0xd0, 0x60, 0x34, 0x60, 0x14,
	0x0a, 0xe2, 0xe2, 0x70, 0xc9, 0x2f, 0xcf, 0xcb, 0xc9, 0x4f, 0x4c, 0x11, 0x52, 0xc6, 0xa6, 0x1c,
	0x26, 0x1b, 0x94, 0x5a, 0x58, 0x9a, 0x5a, 0x5c, 0x22, 0x25, 0x8b, 0x55, 0x51, 0x62, 0x49, 0xa2,
	0x73, 0x46, 0x69, 0x5e, 0xb6, 0x12, 0x83, 0x01, 0xa3, 0x90, 0x2f, 0x17, 0x5b, 0x68, 0x01, 0xd8,
	0x44, 0xfc, 0x8a, 0xa5, 0x14, 0xb0, 0x49, 0x43, 0xb4, 0x06, 0x97, 0x24, 0x96, 0x94, 0x16, 0x83,
	0x1c, 0xe9, 0x64, 0x7e, 0xe2, 0x91, 0x1c, 0xe3, 0x85, 0x47, 0x72, 0x8c, 0x0f, 0x1e, 0xc9, 0x31,
	0x46, 0x69, 0xa6, 0x67, 0x96, 0x64, 0x94, 0x26, 0xe9, 0x25, 0xe7, 0xe7, 0xea, 0x83, 0xb5, 0xea,
	0x83, 0xb5, 0xea, 0x17, 0xa7, 0x64, 0xeb, 0x97, 0x19, 0xe9, 0x83, 0x43, 0xcd, 0x1a, 0x4c, 0x26,
	0xb1, 0x81, 0x29, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x45, 0x3c, 0x58, 0x98, 0x7a, 0x01,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CommanderClient is the client API for Commander service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CommanderClient interface {
	// A Bidirectional streaming RPC established by the data plane agent and is kept open
	CommandChannel(ctx context.Context, opts ...grpc.CallOption) (Commander_CommandChannelClient, error)
	// A streaming RPC established by the data plane agent and is used to download resources associated with commands
	// The download stream will be kept open for the duration of the data transfer and will be closed when its done/
	// The transfer is a stream of chunks as follows:
	// - header
	//    - data chunk count to follow
	//    - resource identifier/metadata
	// - data 1
	// ...
	// - data
	//
	// each data chunk is of a size smaller than the maximum gRPC payload
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Commander_DownloadClient, error)
	// A streaming RPC established by the data plane agent and is used to upload resources associated with commands
	Upload(ctx context.Context, opts ...grpc.CallOption) (Commander_UploadClient, error)
}

type commanderClient struct {
	cc *grpc.ClientConn
}

func NewCommanderClient(cc *grpc.ClientConn) CommanderClient {
	return &commanderClient{cc}
}

func (c *commanderClient) CommandChannel(ctx context.Context, opts ...grpc.CallOption) (Commander_CommandChannelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Commander_serviceDesc.Streams[0], "/f5.nginx.agent.sdk.Commander/CommandChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &commanderCommandChannelClient{stream}
	return x, nil
}

type Commander_CommandChannelClient interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ClientStream
}

type commanderCommandChannelClient struct {
	grpc.ClientStream
}

func (x *commanderCommandChannelClient) Send(m *Command) error {
	return x.ClientStream.SendMsg(m)
}

func (x *commanderCommandChannelClient) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commanderClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Commander_DownloadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Commander_serviceDesc.Streams[1], "/f5.nginx.agent.sdk.Commander/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &commanderDownloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Commander_DownloadClient interface {
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type commanderDownloadClient struct {
	grpc.ClientStream
}

func (x *commanderDownloadClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commanderClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Commander_UploadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Commander_serviceDesc.Streams[2], "/f5.nginx.agent.sdk.Commander/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &commanderUploadClient{stream}
	return x, nil
}

type Commander_UploadClient interface {
	Send(*DataChunk) error
	CloseAndRecv() (*UploadStatus, error)
	grpc.ClientStream
}

type commanderUploadClient struct {
	grpc.ClientStream
}

func (x *commanderUploadClient) Send(m *DataChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *commanderUploadClient) CloseAndRecv() (*UploadStatus, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CommanderServer is the server API for Commander service.
type CommanderServer interface {
	// A Bidirectional streaming RPC established by the data plane agent and is kept open
	CommandChannel(Commander_CommandChannelServer) error
	// A streaming RPC established by the data plane agent and is used to download resources associated with commands
	// The download stream will be kept open for the duration of the data transfer and will be closed when its done/
	// The transfer is a stream of chunks as follows:
	// - header
	//    - data chunk count to follow
	//    - resource identifier/metadata
	// - data 1
	// ...
	// - data
	//
	// each data chunk is of a size smaller than the maximum gRPC payload
	Download(*DownloadRequest, Commander_DownloadServer) error
	// A streaming RPC established by the data plane agent and is used to upload resources associated with commands
	Upload(Commander_UploadServer) error
}

// UnimplementedCommanderServer can be embedded to have forward compatible implementations.
type UnimplementedCommanderServer struct {
}

func (*UnimplementedCommanderServer) CommandChannel(srv Commander_CommandChannelServer) error {
	return status.Errorf(codes.Unimplemented, "method CommandChannel not implemented")
}
func (*UnimplementedCommanderServer) Download(req *DownloadRequest, srv Commander_DownloadServer) error {
	return status.Errorf(codes.Unimplemented, "method Download not implemented")
}
func (*UnimplementedCommanderServer) Upload(srv Commander_UploadServer) error {
	return status.Errorf(codes.Unimplemented, "method Upload not implemented")
}

func RegisterCommanderServer(s *grpc.Server, srv CommanderServer) {
	s.RegisterService(&_Commander_serviceDesc, srv)
}

func _Commander_CommandChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommanderServer).CommandChannel(&commanderCommandChannelServer{stream})
}

type Commander_CommandChannelServer interface {
	Send(*Command) error
	Recv() (*Command, error)
	grpc.ServerStream
}

type commanderCommandChannelServer struct {
	grpc.ServerStream
}

func (x *commanderCommandChannelServer) Send(m *Command) error {
	return x.ServerStream.SendMsg(m)
}

func (x *commanderCommandChannelServer) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Commander_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommanderServer).Download(m, &commanderDownloadServer{stream})
}

type Commander_DownloadServer interface {
	Send(*DataChunk) error
	grpc.ServerStream
}

type commanderDownloadServer struct {
	grpc.ServerStream
}

func (x *commanderDownloadServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Commander_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommanderServer).Upload(&commanderUploadServer{stream})
}

type Commander_UploadServer interface {
	SendAndClose(*UploadStatus) error
	Recv() (*DataChunk, error)
	grpc.ServerStream
}

type commanderUploadServer struct {
	grpc.ServerStream
}

func (x *commanderUploadServer) SendAndClose(m *UploadStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *commanderUploadServer) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Commander_serviceDesc = grpc.ServiceDesc{
	ServiceName: "f5.nginx.agent.sdk.Commander",
	HandlerType: (*CommanderServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CommandChannel",
			Handler:       _Commander_CommandChannel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Download",
			Handler:       _Commander_Download_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Upload",
			Handler:       _Commander_Upload_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "command_svc.proto",
}

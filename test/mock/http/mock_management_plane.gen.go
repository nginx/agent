// Package http provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package http

import (
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Defines values for DownloadResponseType.
const (
	DOWNLOADRESPONSE        DownloadResponseType = "DOWNLOAD_RESPONSE"
	ENCODEDDOWNLOADRESPONSE DownloadResponseType = "ENCODED_DOWNLOAD_RESPONSE"
)

// DownloadResponse defines model for DownloadResponse.
type DownloadResponse struct {
	// Encoded file content encoded
	Encoded bool `json:"encoded"`

	// FileContent Downloaded file content
	FileContent string `json:"fileContent"`
	FilePath    string `json:"filePath"`
	InstanceId  string `json:"instanceId"`

	// Type The type of download response, one of [DOWNLOAD_RESPONSE, ENCODED_DOWNLOAD_RESPONSE].
	Type DownloadResponseType `json:"type"`
}

// DownloadResponseEncoded defines model for DownloadResponseEncoded.
type DownloadResponseEncoded struct {
	// Encoded file content encoded
	Encoded bool `json:"encoded"`

	// FileContent Downloaded file content encoded
	FileContent []byte `json:"fileContent"`
	FilePath    string `json:"filePath"`
	InstanceId  string `json:"instanceId"`

	// Type The type of download response, one of [DOWNLOAD_RESPONSE, ENCODED_DOWNLOAD_RESPONSE].
	Type DownloadResponseType `json:"type"`
}

// DownloadResponseType The type of download response, one of [DOWNLOAD_RESPONSE, ENCODED_DOWNLOAD_RESPONSE].
type DownloadResponseType string

// File defines model for File.
type File struct {
	LastModified time.Time `json:"lastModified"`
	Path         string    `json:"path"`
	Version      string    `json:"version"`
}

// FilesResponse defines model for FilesResponse.
type FilesResponse struct {
	Files      []File `json:"files"`
	InstanceId string `json:"instanceId"`
}

// GetInstanceFilesMetadataParams defines parameters for GetInstanceFilesMetadata.
type GetInstanceFilesMetadataParams struct {
	TenantId *openapi_types.UUID `json:"tenantId,omitempty"`
}

// GetInstanceFileParams defines parameters for GetInstanceFile.
type GetInstanceFileParams struct {
	// Version version ID
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// Encoded file content encoded
	Encoded  bool                `form:"encoded" json:"encoded"`
	TenantId *openapi_types.UUID `json:"tenantId,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Return all files metadata for a data plane instance.
	// (GET /instances/{instanceId}/files/)
	GetInstanceFilesMetadata(c *gin.Context, instanceId string, params GetInstanceFilesMetadataParams)
	// Download a specific file for a data plane instance.
	// (GET /instances/{instanceId}/files/{filePath})
	GetInstanceFile(c *gin.Context, instanceId string, filePath string, params GetInstanceFileParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetInstanceFilesMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetInstanceFilesMetadata(c *gin.Context) {

	var err error

	// ------------- Path parameter "instanceId" -------------
	var instanceId string

	err = runtime.BindStyledParameter("simple", false, "instanceId", c.Param("instanceId"), &instanceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter instanceId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInstanceFilesMetadataParams

	headers := c.Request.Header

	// ------------- Optional header parameter "tenantId" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tenantId")]; found {
		var TenantId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for tenantId, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "tenantId", runtime.ParamLocationHeader, valueList[0], &TenantId)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter tenantId: %w", err), http.StatusBadRequest)
			return
		}

		params.TenantId = &TenantId

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetInstanceFilesMetadata(c, instanceId, params)
}

// GetInstanceFile operation middleware
func (siw *ServerInterfaceWrapper) GetInstanceFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "instanceId" -------------
	var instanceId string

	err = runtime.BindStyledParameter("simple", false, "instanceId", c.Param("instanceId"), &instanceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter instanceId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "filePath" -------------
	var filePath string

	err = runtime.BindStyledParameter("simple", false, "filePath", c.Param("filePath"), &filePath)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter filePath: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInstanceFileParams

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", c.Request.URL.Query(), &params.Version)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter version: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "encoded" -------------

	if paramValue := c.Query("encoded"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument encoded is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "encoded", c.Request.URL.Query(), &params.Encoded)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter encoded: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "tenantId" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tenantId")]; found {
		var TenantId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for tenantId, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "tenantId", runtime.ParamLocationHeader, valueList[0], &TenantId)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter tenantId: %w", err), http.StatusBadRequest)
			return
		}

		params.TenantId = &TenantId

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetInstanceFile(c, instanceId, filePath, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/instances/:instanceId/files/", wrapper.GetInstanceFilesMetadata)
	router.GET(options.BaseURL+"/instances/:instanceId/files/:filePath", wrapper.GetInstanceFile)
}

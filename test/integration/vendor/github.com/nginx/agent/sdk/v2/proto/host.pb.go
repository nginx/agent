// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: host.proto

package proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Represents the host system information
type HostInfo struct {
	// NGINX Agent version
	Agent string `protobuf:"bytes,1,opt,name=agent,proto3" json:"agent"`
	// Host boot time
	Boot uint64 `protobuf:"varint,2,opt,name=boot,proto3" json:"boot"`
	// Hostname
	Hostname string `protobuf:"bytes,3,opt,name=hostname,proto3" json:"hostname"`
	// Display Name
	DisplayName string `protobuf:"bytes,4,opt,name=display_name,json=displayName,proto3" json:"display_name"`
	// OS type (e.g. freebsd, linux, etc)
	OsType string `protobuf:"bytes,5,opt,name=os_type,json=osType,proto3" json:"os-type"`
	// Host UUID
	Uuid string `protobuf:"bytes,6,opt,name=uuid,proto3" json:"uuid"`
	// The native cpu architecture queried at runtime, as returned by `uname -m` or empty string in case of error
	Uname string `protobuf:"bytes,7,opt,name=uname,proto3" json:"uname"`
	// List of disk partitions
	Partitons []*DiskPartition `protobuf:"bytes,8,rep,name=partitons,proto3" json:"disk_partitions"`
	// Network information
	Network *Network `protobuf:"bytes,9,opt,name=network,proto3" json:"network"`
	// List of CPU processor information
	Processor []*CpuInfo `protobuf:"bytes,10,rep,name=processor,proto3" json:"processor"`
	// Release Information
	Release *ReleaseInfo `protobuf:"bytes,11,opt,name=release,proto3" json:"release"`
	// List of tags
	Tags []string `protobuf:"bytes,12,rep,name=tags,proto3" json:"tags"`
	// List of directories that the NGINX Agent is allowed to access on the host
	AgentAccessibleDirs  string   `protobuf:"bytes,13,opt,name=agent_accessible_dirs,json=agentAccessibleDirs,proto3" json:"agent_accessible_dirs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostInfo) Reset()         { *m = HostInfo{} }
func (m *HostInfo) String() string { return proto.CompactTextString(m) }
func (*HostInfo) ProtoMessage()    {}
func (*HostInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_85e40b83b4d50a8d, []int{0}
}
func (m *HostInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostInfo.Merge(m, src)
}
func (m *HostInfo) XXX_Size() int {
	return m.Size()
}
func (m *HostInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HostInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HostInfo proto.InternalMessageInfo

func (m *HostInfo) GetAgent() string {
	if m != nil {
		return m.Agent
	}
	return ""
}

func (m *HostInfo) GetBoot() uint64 {
	if m != nil {
		return m.Boot
	}
	return 0
}

func (m *HostInfo) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *HostInfo) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *HostInfo) GetOsType() string {
	if m != nil {
		return m.OsType
	}
	return ""
}

func (m *HostInfo) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *HostInfo) GetUname() string {
	if m != nil {
		return m.Uname
	}
	return ""
}

func (m *HostInfo) GetPartitons() []*DiskPartition {
	if m != nil {
		return m.Partitons
	}
	return nil
}

func (m *HostInfo) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *HostInfo) GetProcessor() []*CpuInfo {
	if m != nil {
		return m.Processor
	}
	return nil
}

func (m *HostInfo) GetRelease() *ReleaseInfo {
	if m != nil {
		return m.Release
	}
	return nil
}

func (m *HostInfo) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *HostInfo) GetAgentAccessibleDirs() string {
	if m != nil {
		return m.AgentAccessibleDirs
	}
	return ""
}

// Represents a disk partition
type DiskPartition struct {
	// Mount point location
	MountPoint string `protobuf:"bytes,1,opt,name=mount_point,json=mountPoint,proto3" json:"mountpoint"`
	// Device file path
	Device string `protobuf:"bytes,2,opt,name=device,proto3" json:"device"`
	// File system type (e.g. hfs, swap, etc)
	FsType               string   `protobuf:"bytes,3,opt,name=fs_type,json=fsType,proto3" json:"fstype"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskPartition) Reset()         { *m = DiskPartition{} }
func (m *DiskPartition) String() string { return proto.CompactTextString(m) }
func (*DiskPartition) ProtoMessage()    {}
func (*DiskPartition) Descriptor() ([]byte, []int) {
	return fileDescriptor_85e40b83b4d50a8d, []int{1}
}
func (m *DiskPartition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskPartition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskPartition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskPartition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskPartition.Merge(m, src)
}
func (m *DiskPartition) XXX_Size() int {
	return m.Size()
}
func (m *DiskPartition) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskPartition.DiscardUnknown(m)
}

var xxx_messageInfo_DiskPartition proto.InternalMessageInfo

func (m *DiskPartition) GetMountPoint() string {
	if m != nil {
		return m.MountPoint
	}
	return ""
}

func (m *DiskPartition) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *DiskPartition) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

// Represents a network
type Network struct {
	// List of network interfaces
	Interfaces []*NetworkInterface `protobuf:"bytes,1,rep,name=interfaces,proto3" json:"interfaces"`
	// Default network name
	Default              string   `protobuf:"bytes,2,opt,name=default,proto3" json:"default"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Network) Reset()         { *m = Network{} }
func (m *Network) String() string { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()    {}
func (*Network) Descriptor() ([]byte, []int) {
	return fileDescriptor_85e40b83b4d50a8d, []int{2}
}
func (m *Network) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Network) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Network.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Network) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Network.Merge(m, src)
}
func (m *Network) XXX_Size() int {
	return m.Size()
}
func (m *Network) XXX_DiscardUnknown() {
	xxx_messageInfo_Network.DiscardUnknown(m)
}

var xxx_messageInfo_Network proto.InternalMessageInfo

func (m *Network) GetInterfaces() []*NetworkInterface {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func (m *Network) GetDefault() string {
	if m != nil {
		return m.Default
	}
	return ""
}

// Represents a network interface
type NetworkInterface struct {
	// MAC address
	Mac string `protobuf:"bytes,1,opt,name=mac,proto3" json:"mac"`
	// List of IPV6 addresses
	Ipv6 []*Address `protobuf:"bytes,2,rep,name=ipv6,proto3" json:"ipv6"`
	// List of IPV4 addresses
	Ipv4 []*Address `protobuf:"bytes,3,rep,name=ipv4,proto3" json:"ipv4"`
	// Name of network interface
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkInterface) Reset()         { *m = NetworkInterface{} }
func (m *NetworkInterface) String() string { return proto.CompactTextString(m) }
func (*NetworkInterface) ProtoMessage()    {}
func (*NetworkInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_85e40b83b4d50a8d, []int{3}
}
func (m *NetworkInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInterface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterface.Merge(m, src)
}
func (m *NetworkInterface) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterface.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterface proto.InternalMessageInfo

func (m *NetworkInterface) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *NetworkInterface) GetIpv6() []*Address {
	if m != nil {
		return m.Ipv6
	}
	return nil
}

func (m *NetworkInterface) GetIpv4() []*Address {
	if m != nil {
		return m.Ipv4
	}
	return nil
}

func (m *NetworkInterface) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Represents an IP address
type Address struct {
	// Prefix length
	Prefixlen int64 `protobuf:"varint,1,opt,name=prefixlen,proto3" json:"prefixlen"`
	// Netmask
	Netmask string `protobuf:"bytes,2,opt,name=netmask,proto3" json:"netmask"`
	// IP Address
	Address              string   `protobuf:"bytes,3,opt,name=address,proto3" json:"address"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_85e40b83b4d50a8d, []int{4}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetPrefixlen() int64 {
	if m != nil {
		return m.Prefixlen
	}
	return 0
}

func (m *Address) GetNetmask() string {
	if m != nil {
		return m.Netmask
	}
	return ""
}

func (m *Address) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// Represents CPU information
type CpuInfo struct {
	// Model of CPU
	Model string `protobuf:"bytes,1,opt,name=model,proto3" json:"model"`
	// Number of cores
	Cores int32 `protobuf:"varint,2,opt,name=cores,proto3" json:"cores"`
	// CPU architecture
	Architecture string `protobuf:"bytes,3,opt,name=architecture,proto3" json:"architecture"`
	// CPU clock speed in MHz
	Mhz float64 `protobuf:"fixed64,4,opt,name=mhz,proto3" json:"mhz"`
	// Hypervisor (e.g. VMWare, KVM, etc.)
	Hypervisor string `protobuf:"bytes,5,opt,name=hypervisor,proto3" json:"hypervisor"`
	// Total number of CPUs
	Cpus int32 `protobuf:"varint,6,opt,name=cpus,proto3" json:"cpus"`
	// Type of hypervisor (e.g guest or host)
	Virtualization string `protobuf:"bytes,7,opt,name=virtualization,proto3" json:"virtualization"`
	// Map of caches with names as the keys and size in bytes as the values
	Cache                map[string]string `protobuf:"bytes,8,rep,name=cache,proto3" json:"cache" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CpuInfo) Reset()         { *m = CpuInfo{} }
func (m *CpuInfo) String() string { return proto.CompactTextString(m) }
func (*CpuInfo) ProtoMessage()    {}
func (*CpuInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_85e40b83b4d50a8d, []int{5}
}
func (m *CpuInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuInfo.Merge(m, src)
}
func (m *CpuInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuInfo proto.InternalMessageInfo

func (m *CpuInfo) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *CpuInfo) GetCores() int32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *CpuInfo) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *CpuInfo) GetMhz() float64 {
	if m != nil {
		return m.Mhz
	}
	return 0
}

func (m *CpuInfo) GetHypervisor() string {
	if m != nil {
		return m.Hypervisor
	}
	return ""
}

func (m *CpuInfo) GetCpus() int32 {
	if m != nil {
		return m.Cpus
	}
	return 0
}

func (m *CpuInfo) GetVirtualization() string {
	if m != nil {
		return m.Virtualization
	}
	return ""
}

func (m *CpuInfo) GetCache() map[string]string {
	if m != nil {
		return m.Cache
	}
	return nil
}

// Represents release information
type ReleaseInfo struct {
	// OS type (e.g. freebsd, linux, etc)
	Codename string `protobuf:"bytes,1,opt,name=codename,proto3" json:"codename"`
	// OS name (e.g. ubuntu, linuxmint, etc)
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id"`
	// OS family (e.g. debian, rhel)
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	// Version of the OS kernel
	VersionId string `protobuf:"bytes,4,opt,name=version_id,json=versionId,proto3" json:"version_id"`
	// Version of the OS
	Version              string   `protobuf:"bytes,5,opt,name=version,proto3" json:"version"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReleaseInfo) Reset()         { *m = ReleaseInfo{} }
func (m *ReleaseInfo) String() string { return proto.CompactTextString(m) }
func (*ReleaseInfo) ProtoMessage()    {}
func (*ReleaseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_85e40b83b4d50a8d, []int{6}
}
func (m *ReleaseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReleaseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReleaseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReleaseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseInfo.Merge(m, src)
}
func (m *ReleaseInfo) XXX_Size() int {
	return m.Size()
}
func (m *ReleaseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseInfo proto.InternalMessageInfo

func (m *ReleaseInfo) GetCodename() string {
	if m != nil {
		return m.Codename
	}
	return ""
}

func (m *ReleaseInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ReleaseInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ReleaseInfo) GetVersionId() string {
	if m != nil {
		return m.VersionId
	}
	return ""
}

func (m *ReleaseInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterType((*HostInfo)(nil), "f5.nginx.agent.sdk.HostInfo")
	proto.RegisterType((*DiskPartition)(nil), "f5.nginx.agent.sdk.DiskPartition")
	proto.RegisterType((*Network)(nil), "f5.nginx.agent.sdk.Network")
	proto.RegisterType((*NetworkInterface)(nil), "f5.nginx.agent.sdk.NetworkInterface")
	proto.RegisterType((*Address)(nil), "f5.nginx.agent.sdk.Address")
	proto.RegisterType((*CpuInfo)(nil), "f5.nginx.agent.sdk.CpuInfo")
	proto.RegisterMapType((map[string]string)(nil), "f5.nginx.agent.sdk.CpuInfo.CacheEntry")
	proto.RegisterType((*ReleaseInfo)(nil), "f5.nginx.agent.sdk.ReleaseInfo")
}

func init() { proto.RegisterFile("host.proto", fileDescriptor_85e40b83b4d50a8d) }

var fileDescriptor_85e40b83b4d50a8d = []byte{
	// 950 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x41, 0x8f, 0xdb, 0x44,
	0x14, 0x96, 0xe3, 0xcd, 0x7a, 0xf3, 0xb2, 0x5b, 0x56, 0x53, 0x40, 0x6e, 0x41, 0xeb, 0x10, 0x0a,
	0x0a, 0x42, 0x75, 0xa4, 0xed, 0x02, 0xa5, 0x9c, 0x9a, 0x16, 0xe8, 0x1e, 0xa8, 0xaa, 0xd1, 0x9e,
	0xb8, 0x44, 0x5e, 0x7b, 0x92, 0x8c, 0x92, 0x78, 0x2c, 0xcf, 0x38, 0x34, 0x7b, 0x46, 0x48, 0xfc,
	0x11, 0x24, 0x7e, 0x06, 0xe2, 0xc2, 0x91, 0x5f, 0x60, 0xa1, 0x3d, 0xfa, 0x57, 0xa0, 0x79, 0x33,
	0x8e, 0xb3, 0x4b, 0xa8, 0x7a, 0x79, 0xf3, 0xde, 0xe7, 0x6f, 0x9e, 0xc7, 0xef, 0x7d, 0xf3, 0x0c,
	0x30, 0x13, 0x52, 0x85, 0x59, 0x2e, 0x94, 0x20, 0x64, 0xf2, 0x45, 0x98, 0x4e, 0x79, 0xfa, 0x3a,
	0x8c, 0xa6, 0x2c, 0x55, 0xa1, 0x4c, 0xe6, 0xf7, 0x61, 0x2a, 0xa6, 0xc2, 0x3c, 0xef, 0xff, 0xd6,
	0x86, 0x83, 0x17, 0x42, 0xaa, 0xf3, 0x74, 0x22, 0x48, 0x00, 0x6d, 0x64, 0xf9, 0x4e, 0xcf, 0x19,
	0x74, 0x46, 0x9d, 0xaa, 0x0c, 0x0c, 0x40, 0xcd, 0x42, 0x3e, 0x84, 0xbd, 0x4b, 0x21, 0x94, 0xdf,
	0xea, 0x39, 0x83, 0xbd, 0xd1, 0x41, 0x55, 0x06, 0x18, 0x53, 0xb4, 0x64, 0x00, 0x07, 0xfa, 0xcd,
	0x69, 0xb4, 0x64, 0xbe, 0x8b, 0x19, 0x0e, 0xab, 0x32, 0xd8, 0x60, 0x74, 0xe3, 0x91, 0x47, 0x70,
	0x98, 0x70, 0x99, 0x2d, 0xa2, 0xf5, 0x18, 0xd9, 0x7b, 0xc8, 0x3e, 0xae, 0xca, 0xe0, 0x06, 0x4e,
	0xbb, 0x36, 0x7a, 0xa9, 0x37, 0x3d, 0x00, 0x4f, 0xc8, 0xb1, 0x5a, 0x67, 0xcc, 0x6f, 0x23, 0xbf,
	0x5b, 0x95, 0x81, 0x27, 0xe4, 0x43, 0x0d, 0xd1, 0x7d, 0x21, 0x2f, 0xd6, 0x19, 0xd3, 0x47, 0x2c,
	0x0a, 0x9e, 0xf8, 0xfb, 0x48, 0xc1, 0x23, 0xea, 0x98, 0xa2, 0xd5, 0x5f, 0x58, 0xe0, 0x1b, 0xbd,
	0xe6, 0x0b, 0x11, 0xa0, 0x66, 0x21, 0x17, 0xd0, 0xc9, 0xa2, 0x5c, 0x71, 0x25, 0x52, 0xe9, 0x1f,
	0xf4, 0xdc, 0x41, 0xf7, 0xf4, 0xa3, 0xf0, 0xbf, 0x35, 0x0c, 0x9f, 0x73, 0x39, 0x7f, 0x85, 0x44,
	0x2e, 0xd2, 0xd1, 0xdd, 0xaa, 0x0c, 0xde, 0x49, 0xb8, 0x9c, 0x8f, 0xb3, 0x1a, 0x93, 0xb4, 0x49,
	0x44, 0x46, 0xe0, 0xa5, 0x4c, 0xfd, 0x24, 0xf2, 0xb9, 0xdf, 0xe9, 0x39, 0x83, 0xee, 0xe9, 0x07,
	0xbb, 0x72, 0xbe, 0x34, 0x14, 0xf3, 0x5d, 0x96, 0x4f, 0x6b, 0x87, 0xbc, 0x80, 0x4e, 0x96, 0x8b,
	0x98, 0x49, 0x29, 0x72, 0x1f, 0xf0, 0x64, 0x3b, 0xb3, 0x3c, 0xcb, 0x0a, 0xdd, 0xcc, 0xd1, 0x51,
	0x55, 0x06, 0xcd, 0x0e, 0xda, 0xb8, 0xe4, 0x3b, 0xf0, 0x72, 0xb6, 0x60, 0x91, 0x64, 0x7e, 0x17,
	0x4f, 0x13, 0xec, 0xca, 0x43, 0x0d, 0x05, 0x73, 0xe1, 0x89, 0xec, 0x1e, 0x5a, 0x3b, 0xba, 0xd4,
	0x2a, 0x9a, 0x4a, 0xff, 0xb0, 0xe7, 0xd6, 0xa5, 0xd6, 0x31, 0x45, 0x4b, 0x7e, 0x80, 0xf7, 0x30,
	0xd9, 0x38, 0x8a, 0xf5, 0x7b, 0xf9, 0xe5, 0x82, 0x8d, 0x13, 0x9e, 0x4b, 0xff, 0x08, 0x4b, 0x7f,
	0xaf, 0x2a, 0x83, 0xdd, 0x04, 0x7a, 0x17, 0xe1, 0xa7, 0x1b, 0xf4, 0x39, 0xcf, 0x65, 0xff, 0x57,
	0x07, 0x8e, 0x6e, 0x14, 0x9d, 0x0c, 0xa1, 0xbb, 0x14, 0x45, 0xaa, 0xc6, 0x99, 0xe0, 0x1b, 0xcd,
	0xde, 0xa9, 0xca, 0x00, 0x10, 0x46, 0x94, 0x1a, 0xff, 0x95, 0xf6, 0x49, 0x1f, 0xf6, 0x13, 0xb6,
	0xe2, 0x31, 0x43, 0xfd, 0x76, 0x46, 0x50, 0x95, 0x81, 0x45, 0xa8, 0x5d, 0xc9, 0xc7, 0xe0, 0x4d,
	0xac, 0xc8, 0xdc, 0x86, 0x34, 0x91, 0x46, 0x63, 0x13, 0xd4, 0x58, 0xff, 0x17, 0x07, 0x3c, 0xdb,
	0x2c, 0x72, 0x01, 0xc0, 0x53, 0xc5, 0xf2, 0x49, 0x14, 0x33, 0xe9, 0x3b, 0xd8, 0x97, 0x07, 0x6f,
	0xe8, 0xee, 0x79, 0x4d, 0x36, 0x47, 0x6d, 0xf6, 0xd2, 0x2d, 0x9f, 0x7c, 0x02, 0x5e, 0xc2, 0x26,
	0x51, 0xb1, 0x50, 0xf6, 0xac, 0xd8, 0x01, 0x0b, 0xd1, 0xda, 0xe9, 0xff, 0xe1, 0xc0, 0xf1, 0xed,
	0xbc, 0xe4, 0x1e, 0xb8, 0xcb, 0x28, 0xb6, 0xf5, 0xf0, 0xaa, 0x32, 0xd0, 0x21, 0xd5, 0x86, 0x7c,
	0x0d, 0x7b, 0x3c, 0x5b, 0x7d, 0xe9, 0xb7, 0xfe, 0x5f, 0x3e, 0x4f, 0x93, 0x24, 0x67, 0x52, 0x9a,
	0x76, 0x6a, 0x32, 0x45, 0x6b, 0xb7, 0x9e, 0xf9, 0xee, 0xdb, 0x6f, 0x3d, 0xc3, 0xad, 0x67, 0x5a,
	0x27, 0x5b, 0xb7, 0x1c, 0x9f, 0xe2, 0x95, 0x43, 0xdb, 0xff, 0xd9, 0x01, 0xcf, 0xee, 0x24, 0x9f,
	0x6b, 0x8d, 0xb3, 0x09, 0x7f, 0xbd, 0x60, 0x29, 0x7e, 0x80, 0x5b, 0xcb, 0xd8, 0x82, 0xb4, 0x71,
	0x75, 0x8d, 0x52, 0xa6, 0x96, 0x91, 0x9c, 0x6f, 0xd7, 0xc8, 0x42, 0xb4, 0x76, 0x34, 0x2d, 0x32,
	0xe9, 0x6d, 0x47, 0x91, 0x66, 0x21, 0x5a, 0x3b, 0xfd, 0xdf, 0x5d, 0xf0, 0xec, 0xd5, 0xd1, 0x53,
	0x62, 0x29, 0x12, 0xb6, 0xd8, 0x9e, 0x83, 0x08, 0x50, 0xb3, 0x68, 0x42, 0x2c, 0x72, 0x26, 0xf1,
	0xc5, 0x6d, 0x43, 0x40, 0x80, 0x9a, 0x85, 0x9c, 0xc1, 0x61, 0x94, 0xc7, 0x33, 0xae, 0x58, 0xac,
	0x8a, 0xbc, 0xd6, 0x12, 0x0e, 0xb8, 0x6d, 0x9c, 0xde, 0x88, 0xb0, 0x73, 0xb3, 0x2b, 0xac, 0x93,
	0x63, 0x3b, 0x37, 0xbb, 0xa2, 0xda, 0x90, 0x10, 0x60, 0xb6, 0xce, 0x58, 0xbe, 0xe2, 0xfa, 0xfa,
	0xb7, 0x1b, 0xad, 0x37, 0x28, 0xdd, 0xf2, 0x75, 0xcd, 0xe3, 0xac, 0x90, 0x38, 0x06, 0xdb, 0xa6,
	0xe6, 0x3a, 0xa6, 0x68, 0xc9, 0x13, 0xb8, 0xb3, 0xe2, 0xb9, 0x2a, 0xa2, 0x05, 0xbf, 0x8a, 0xf4,
	0x65, 0xb2, 0xf3, 0x90, 0x54, 0x65, 0x70, 0xeb, 0x09, 0xbd, 0x15, 0x93, 0xef, 0xa1, 0x1d, 0x47,
	0xf1, 0x8c, 0xd9, 0xe9, 0xf8, 0xe9, 0x1b, 0x66, 0x50, 0xf8, 0x4c, 0x13, 0xbf, 0x4d, 0x55, 0xbe,
	0xb6, 0x35, 0xd2, 0x31, 0x35, 0xcb, 0xfd, 0xc7, 0x00, 0xcd, 0x73, 0x72, 0x0c, 0xee, 0x9c, 0xad,
	0x4d, 0xc5, 0xa9, 0x76, 0xc9, 0xbb, 0xd0, 0x5e, 0x45, 0x8b, 0xc2, 0xde, 0x56, 0x6a, 0x82, 0x27,
	0xad, 0xc7, 0x4e, 0xff, 0x4f, 0x07, 0xba, 0x5b, 0xe3, 0x49, 0xff, 0x78, 0x62, 0x91, 0x30, 0x14,
	0x99, 0xd3, 0xfc, 0x78, 0x6a, 0x8c, 0x6e, 0x3c, 0xf2, 0x3e, 0xb4, 0x78, 0x62, 0xe5, 0xb2, 0x5f,
	0x95, 0x41, 0x8b, 0x27, 0xb4, 0xc5, 0x93, 0x8d, 0x44, 0xdd, 0x5d, 0x12, 0x25, 0x0f, 0x01, 0x56,
	0x2c, 0x97, 0x5c, 0xa4, 0x63, 0x9e, 0x58, 0x19, 0x63, 0xf1, 0x1b, 0x94, 0x76, 0xac, 0x7f, 0x9e,
	0x68, 0xc5, 0xd9, 0x60, 0xfb, 0x47, 0x65, 0x21, 0x5a, 0x3b, 0xa3, 0xaf, 0xfe, 0xba, 0x3e, 0x71,
	0xfe, 0xbe, 0x3e, 0x71, 0xfe, 0xb9, 0x3e, 0x71, 0x7e, 0xfc, 0x6c, 0xca, 0xd5, 0xac, 0xb8, 0x0c,
	0x63, 0xb1, 0x1c, 0x62, 0x39, 0x87, 0x58, 0xce, 0xa1, 0x4c, 0xe6, 0xc3, 0xd5, 0xe9, 0x10, 0xff,
	0xd6, 0xdf, 0xa0, 0xbd, 0xdc, 0xc7, 0xe5, 0xd1, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4a, 0x49,
	0xf4, 0x5f, 0xe8, 0x07, 0x00, 0x00,
}

func (m *HostInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AgentAccessibleDirs) > 0 {
		i -= len(m.AgentAccessibleDirs)
		copy(dAtA[i:], m.AgentAccessibleDirs)
		i = encodeVarintHost(dAtA, i, uint64(len(m.AgentAccessibleDirs)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintHost(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Release != nil {
		{
			size, err := m.Release.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHost(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Processor) > 0 {
		for iNdEx := len(m.Processor) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Processor[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHost(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Network != nil {
		{
			size, err := m.Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHost(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Partitons) > 0 {
		for iNdEx := len(m.Partitons) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitons[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHost(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Uname) > 0 {
		i -= len(m.Uname)
		copy(dAtA[i:], m.Uname)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Uname)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OsType) > 0 {
		i -= len(m.OsType)
		copy(dAtA[i:], m.OsType)
		i = encodeVarintHost(dAtA, i, uint64(len(m.OsType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintHost(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Boot != 0 {
		i = encodeVarintHost(dAtA, i, uint64(m.Boot))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Agent) > 0 {
		i -= len(m.Agent)
		copy(dAtA[i:], m.Agent)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Agent)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiskPartition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskPartition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskPartition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FsType) > 0 {
		i -= len(m.FsType)
		copy(dAtA[i:], m.FsType)
		i = encodeVarintHost(dAtA, i, uint64(len(m.FsType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MountPoint) > 0 {
		i -= len(m.MountPoint)
		copy(dAtA[i:], m.MountPoint)
		i = encodeVarintHost(dAtA, i, uint64(len(m.MountPoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Network) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Default) > 0 {
		i -= len(m.Default)
		copy(dAtA[i:], m.Default)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Default)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Interfaces) > 0 {
		for iNdEx := len(m.Interfaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interfaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHost(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ipv4) > 0 {
		for iNdEx := len(m.Ipv4) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ipv4[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHost(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Ipv6) > 0 {
		for iNdEx := len(m.Ipv6) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ipv6[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHost(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Netmask) > 0 {
		i -= len(m.Netmask)
		copy(dAtA[i:], m.Netmask)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Netmask)))
		i--
		dAtA[i] = 0x12
	}
	if m.Prefixlen != 0 {
		i = encodeVarintHost(dAtA, i, uint64(m.Prefixlen))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CpuInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cache) > 0 {
		for k := range m.Cache {
			v := m.Cache[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintHost(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintHost(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintHost(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Virtualization) > 0 {
		i -= len(m.Virtualization)
		copy(dAtA[i:], m.Virtualization)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Virtualization)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Cpus != 0 {
		i = encodeVarintHost(dAtA, i, uint64(m.Cpus))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Hypervisor) > 0 {
		i -= len(m.Hypervisor)
		copy(dAtA[i:], m.Hypervisor)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Hypervisor)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Mhz != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mhz))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cores != 0 {
		i = encodeVarintHost(dAtA, i, uint64(m.Cores))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReleaseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReleaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReleaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.VersionId) > 0 {
		i -= len(m.VersionId)
		copy(dAtA[i:], m.VersionId)
		i = encodeVarintHost(dAtA, i, uint64(len(m.VersionId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Codename) > 0 {
		i -= len(m.Codename)
		copy(dAtA[i:], m.Codename)
		i = encodeVarintHost(dAtA, i, uint64(len(m.Codename)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintHost(dAtA []byte, offset int, v uint64) int {
	offset -= sovHost(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HostInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Agent)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.Boot != 0 {
		n += 1 + sovHost(uint64(m.Boot))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.OsType)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if len(m.Partitons) > 0 {
		for _, e := range m.Partitons {
			l = e.Size()
			n += 1 + l + sovHost(uint64(l))
		}
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovHost(uint64(l))
	}
	if len(m.Processor) > 0 {
		for _, e := range m.Processor {
			l = e.Size()
			n += 1 + l + sovHost(uint64(l))
		}
	}
	if m.Release != nil {
		l = m.Release.Size()
		n += 1 + l + sovHost(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovHost(uint64(l))
		}
	}
	l = len(m.AgentAccessibleDirs)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskPartition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MountPoint)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.FsType)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovHost(uint64(l))
		}
	}
	l = len(m.Default)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if len(m.Ipv6) > 0 {
		for _, e := range m.Ipv6 {
			l = e.Size()
			n += 1 + l + sovHost(uint64(l))
		}
	}
	if len(m.Ipv4) > 0 {
		for _, e := range m.Ipv4 {
			l = e.Size()
			n += 1 + l + sovHost(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefixlen != 0 {
		n += 1 + sovHost(uint64(m.Prefixlen))
	}
	l = len(m.Netmask)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.Cores != 0 {
		n += 1 + sovHost(uint64(m.Cores))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.Mhz != 0 {
		n += 9
	}
	l = len(m.Hypervisor)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.Cpus != 0 {
		n += 1 + sovHost(uint64(m.Cpus))
	}
	l = len(m.Virtualization)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if len(m.Cache) > 0 {
		for k, v := range m.Cache {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovHost(uint64(len(k))) + 1 + len(v) + sovHost(uint64(len(v)))
			n += mapEntrySize + 1 + sovHost(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReleaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Codename)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.VersionId)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovHost(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovHost(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHost(x uint64) (n int) {
	return sovHost(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HostInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Agent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boot", wireType)
			}
			m.Boot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Boot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitons = append(m.Partitons, &DiskPartition{})
			if err := m.Partitons[len(m.Partitons)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processor = append(m.Processor, &CpuInfo{})
			if err := m.Processor[len(m.Processor)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Release == nil {
				m.Release = &ReleaseInfo{}
			}
			if err := m.Release.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentAccessibleDirs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentAccessibleDirs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskPartition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskPartition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskPartition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FsType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &NetworkInterface{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Default = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6 = append(m.Ipv6, &Address{})
			if err := m.Ipv6[len(m.Ipv6)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = append(m.Ipv4, &Address{})
			if err := m.Ipv4[len(m.Ipv4)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixlen", wireType)
			}
			m.Prefixlen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prefixlen |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Netmask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Netmask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cores |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mhz", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mhz = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hypervisor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hypervisor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			m.Cpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtualization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Virtualization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cache == nil {
				m.Cache = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHost
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHost
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthHost
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthHost
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHost
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthHost
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthHost
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipHost(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthHost
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Cache[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReleaseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHost
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReleaseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReleaseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHost
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHost
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHost
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHost(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHost
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHost(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHost
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHost
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHost
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHost
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHost
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHost
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHost        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHost          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHost = fmt.Errorf("proto: unexpected end of group")
)

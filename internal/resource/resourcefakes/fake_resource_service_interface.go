// Code generated by counterfeiter. DO NOT EDIT.
package resourcefakes

import (
	"context"
	"sync"

	v1 "github.com/nginx/agent/v3/api/grpc/mpi/v1"
	"github.com/nginx/agent/v3/internal/model"
	"github.com/nginxinc/nginx-plus-go-client/v2/client"
	"google.golang.org/protobuf/types/known/structpb"
)

type FakeResourceServiceInterface struct {
	AddInstancesStub        func([]*v1.Instance) *v1.Resource
	addInstancesMutex       sync.RWMutex
	addInstancesArgsForCall []struct {
		arg1 []*v1.Instance
	}
	addInstancesReturns struct {
		result1 *v1.Resource
	}
	addInstancesReturnsOnCall map[int]struct {
		result1 *v1.Resource
	}
	ApplyConfigStub        func(context.Context, string) (*model.NginxConfigContext, error)
	applyConfigMutex       sync.RWMutex
	applyConfigArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	applyConfigReturns struct {
		result1 *model.NginxConfigContext
		result2 error
	}
	applyConfigReturnsOnCall map[int]struct {
		result1 *model.NginxConfigContext
		result2 error
	}
	DeleteInstancesStub        func(context.Context, []*v1.Instance) *v1.Resource
	deleteInstancesMutex       sync.RWMutex
	deleteInstancesArgsForCall []struct {
		arg1 context.Context
		arg2 []*v1.Instance
	}
	deleteInstancesReturns struct {
		result1 *v1.Resource
	}
	deleteInstancesReturnsOnCall map[int]struct {
		result1 *v1.Resource
	}
	GetHTTPUpstreamServersStub        func(context.Context, *v1.Instance, string) ([]client.UpstreamServer, error)
	getHTTPUpstreamServersMutex       sync.RWMutex
	getHTTPUpstreamServersArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
	}
	getHTTPUpstreamServersReturns struct {
		result1 []client.UpstreamServer
		result2 error
	}
	getHTTPUpstreamServersReturnsOnCall map[int]struct {
		result1 []client.UpstreamServer
		result2 error
	}
	GetStreamUpstreamsStub        func(context.Context, *v1.Instance) (*client.StreamUpstreams, error)
	getStreamUpstreamsMutex       sync.RWMutex
	getStreamUpstreamsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
	}
	getStreamUpstreamsReturns struct {
		result1 *client.StreamUpstreams
		result2 error
	}
	getStreamUpstreamsReturnsOnCall map[int]struct {
		result1 *client.StreamUpstreams
		result2 error
	}
	GetUpstreamsStub        func(context.Context, *v1.Instance) (*client.Upstreams, error)
	getUpstreamsMutex       sync.RWMutex
	getUpstreamsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
	}
	getUpstreamsReturns struct {
		result1 *client.Upstreams
		result2 error
	}
	getUpstreamsReturnsOnCall map[int]struct {
		result1 *client.Upstreams
		result2 error
	}
	InstanceStub        func(string) *v1.Instance
	instanceMutex       sync.RWMutex
	instanceArgsForCall []struct {
		arg1 string
	}
	instanceReturns struct {
		result1 *v1.Instance
	}
	instanceReturnsOnCall map[int]struct {
		result1 *v1.Instance
	}
	UpdateHTTPUpstreamServersStub        func(context.Context, *v1.Instance, string, []*structpb.Struct) ([]client.UpstreamServer, []client.UpstreamServer, []client.UpstreamServer, error)
	updateHTTPUpstreamServersMutex       sync.RWMutex
	updateHTTPUpstreamServersArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
		arg4 []*structpb.Struct
	}
	updateHTTPUpstreamServersReturns struct {
		result1 []client.UpstreamServer
		result2 []client.UpstreamServer
		result3 []client.UpstreamServer
		result4 error
	}
	updateHTTPUpstreamServersReturnsOnCall map[int]struct {
		result1 []client.UpstreamServer
		result2 []client.UpstreamServer
		result3 []client.UpstreamServer
		result4 error
	}
	UpdateInstancesStub        func(context.Context, []*v1.Instance) *v1.Resource
	updateInstancesMutex       sync.RWMutex
	updateInstancesArgsForCall []struct {
		arg1 context.Context
		arg2 []*v1.Instance
	}
	updateInstancesReturns struct {
		result1 *v1.Resource
	}
	updateInstancesReturnsOnCall map[int]struct {
		result1 *v1.Resource
	}
	UpdateStreamServersStub        func(context.Context, *v1.Instance, string, []*structpb.Struct) ([]client.StreamUpstreamServer, []client.StreamUpstreamServer, []client.StreamUpstreamServer, error)
	updateStreamServersMutex       sync.RWMutex
	updateStreamServersArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
		arg4 []*structpb.Struct
	}
	updateStreamServersReturns struct {
		result1 []client.StreamUpstreamServer
		result2 []client.StreamUpstreamServer
		result3 []client.StreamUpstreamServer
		result4 error
	}
	updateStreamServersReturnsOnCall map[int]struct {
		result1 []client.StreamUpstreamServer
		result2 []client.StreamUpstreamServer
		result3 []client.StreamUpstreamServer
		result4 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResourceServiceInterface) AddInstances(arg1 []*v1.Instance) *v1.Resource {
	var arg1Copy []*v1.Instance
	if arg1 != nil {
		arg1Copy = make([]*v1.Instance, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.addInstancesMutex.Lock()
	ret, specificReturn := fake.addInstancesReturnsOnCall[len(fake.addInstancesArgsForCall)]
	fake.addInstancesArgsForCall = append(fake.addInstancesArgsForCall, struct {
		arg1 []*v1.Instance
	}{arg1Copy})
	stub := fake.AddInstancesStub
	fakeReturns := fake.addInstancesReturns
	fake.recordInvocation("AddInstances", []interface{}{arg1Copy})
	fake.addInstancesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceServiceInterface) AddInstancesCallCount() int {
	fake.addInstancesMutex.RLock()
	defer fake.addInstancesMutex.RUnlock()
	return len(fake.addInstancesArgsForCall)
}

func (fake *FakeResourceServiceInterface) AddInstancesCalls(stub func([]*v1.Instance) *v1.Resource) {
	fake.addInstancesMutex.Lock()
	defer fake.addInstancesMutex.Unlock()
	fake.AddInstancesStub = stub
}

func (fake *FakeResourceServiceInterface) AddInstancesArgsForCall(i int) []*v1.Instance {
	fake.addInstancesMutex.RLock()
	defer fake.addInstancesMutex.RUnlock()
	argsForCall := fake.addInstancesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceServiceInterface) AddInstancesReturns(result1 *v1.Resource) {
	fake.addInstancesMutex.Lock()
	defer fake.addInstancesMutex.Unlock()
	fake.AddInstancesStub = nil
	fake.addInstancesReturns = struct {
		result1 *v1.Resource
	}{result1}
}

func (fake *FakeResourceServiceInterface) AddInstancesReturnsOnCall(i int, result1 *v1.Resource) {
	fake.addInstancesMutex.Lock()
	defer fake.addInstancesMutex.Unlock()
	fake.AddInstancesStub = nil
	if fake.addInstancesReturnsOnCall == nil {
		fake.addInstancesReturnsOnCall = make(map[int]struct {
			result1 *v1.Resource
		})
	}
	fake.addInstancesReturnsOnCall[i] = struct {
		result1 *v1.Resource
	}{result1}
}

func (fake *FakeResourceServiceInterface) ApplyConfig(arg1 context.Context, arg2 string) (*model.NginxConfigContext, error) {
	fake.applyConfigMutex.Lock()
	ret, specificReturn := fake.applyConfigReturnsOnCall[len(fake.applyConfigArgsForCall)]
	fake.applyConfigArgsForCall = append(fake.applyConfigArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ApplyConfigStub
	fakeReturns := fake.applyConfigReturns
	fake.recordInvocation("ApplyConfig", []interface{}{arg1, arg2})
	fake.applyConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceServiceInterface) ApplyConfigCallCount() int {
	fake.applyConfigMutex.RLock()
	defer fake.applyConfigMutex.RUnlock()
	return len(fake.applyConfigArgsForCall)
}

func (fake *FakeResourceServiceInterface) ApplyConfigCalls(stub func(context.Context, string) (*model.NginxConfigContext, error)) {
	fake.applyConfigMutex.Lock()
	defer fake.applyConfigMutex.Unlock()
	fake.ApplyConfigStub = stub
}

func (fake *FakeResourceServiceInterface) ApplyConfigArgsForCall(i int) (context.Context, string) {
	fake.applyConfigMutex.RLock()
	defer fake.applyConfigMutex.RUnlock()
	argsForCall := fake.applyConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceServiceInterface) ApplyConfigReturns(result1 *model.NginxConfigContext, result2 error) {
	fake.applyConfigMutex.Lock()
	defer fake.applyConfigMutex.Unlock()
	fake.ApplyConfigStub = nil
	fake.applyConfigReturns = struct {
		result1 *model.NginxConfigContext
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceServiceInterface) ApplyConfigReturnsOnCall(i int, result1 *model.NginxConfigContext, result2 error) {
	fake.applyConfigMutex.Lock()
	defer fake.applyConfigMutex.Unlock()
	fake.ApplyConfigStub = nil
	if fake.applyConfigReturnsOnCall == nil {
		fake.applyConfigReturnsOnCall = make(map[int]struct {
			result1 *model.NginxConfigContext
			result2 error
		})
	}
	fake.applyConfigReturnsOnCall[i] = struct {
		result1 *model.NginxConfigContext
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceServiceInterface) DeleteInstances(arg1 context.Context, arg2 []*v1.Instance) *v1.Resource {
	var arg2Copy []*v1.Instance
	if arg2 != nil {
		arg2Copy = make([]*v1.Instance, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.deleteInstancesMutex.Lock()
	ret, specificReturn := fake.deleteInstancesReturnsOnCall[len(fake.deleteInstancesArgsForCall)]
	fake.deleteInstancesArgsForCall = append(fake.deleteInstancesArgsForCall, struct {
		arg1 context.Context
		arg2 []*v1.Instance
	}{arg1, arg2Copy})
	stub := fake.DeleteInstancesStub
	fakeReturns := fake.deleteInstancesReturns
	fake.recordInvocation("DeleteInstances", []interface{}{arg1, arg2Copy})
	fake.deleteInstancesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceServiceInterface) DeleteInstancesCallCount() int {
	fake.deleteInstancesMutex.RLock()
	defer fake.deleteInstancesMutex.RUnlock()
	return len(fake.deleteInstancesArgsForCall)
}

func (fake *FakeResourceServiceInterface) DeleteInstancesCalls(stub func(context.Context, []*v1.Instance) *v1.Resource) {
	fake.deleteInstancesMutex.Lock()
	defer fake.deleteInstancesMutex.Unlock()
	fake.DeleteInstancesStub = stub
}

func (fake *FakeResourceServiceInterface) DeleteInstancesArgsForCall(i int) (context.Context, []*v1.Instance) {
	fake.deleteInstancesMutex.RLock()
	defer fake.deleteInstancesMutex.RUnlock()
	argsForCall := fake.deleteInstancesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceServiceInterface) DeleteInstancesReturns(result1 *v1.Resource) {
	fake.deleteInstancesMutex.Lock()
	defer fake.deleteInstancesMutex.Unlock()
	fake.DeleteInstancesStub = nil
	fake.deleteInstancesReturns = struct {
		result1 *v1.Resource
	}{result1}
}

func (fake *FakeResourceServiceInterface) DeleteInstancesReturnsOnCall(i int, result1 *v1.Resource) {
	fake.deleteInstancesMutex.Lock()
	defer fake.deleteInstancesMutex.Unlock()
	fake.DeleteInstancesStub = nil
	if fake.deleteInstancesReturnsOnCall == nil {
		fake.deleteInstancesReturnsOnCall = make(map[int]struct {
			result1 *v1.Resource
		})
	}
	fake.deleteInstancesReturnsOnCall[i] = struct {
		result1 *v1.Resource
	}{result1}
}

func (fake *FakeResourceServiceInterface) GetHTTPUpstreamServers(arg1 context.Context, arg2 *v1.Instance, arg3 string) ([]client.UpstreamServer, error) {
	fake.getHTTPUpstreamServersMutex.Lock()
	ret, specificReturn := fake.getHTTPUpstreamServersReturnsOnCall[len(fake.getHTTPUpstreamServersArgsForCall)]
	fake.getHTTPUpstreamServersArgsForCall = append(fake.getHTTPUpstreamServersArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetHTTPUpstreamServersStub
	fakeReturns := fake.getHTTPUpstreamServersReturns
	fake.recordInvocation("GetHTTPUpstreamServers", []interface{}{arg1, arg2, arg3})
	fake.getHTTPUpstreamServersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceServiceInterface) GetHTTPUpstreamServersCallCount() int {
	fake.getHTTPUpstreamServersMutex.RLock()
	defer fake.getHTTPUpstreamServersMutex.RUnlock()
	return len(fake.getHTTPUpstreamServersArgsForCall)
}

func (fake *FakeResourceServiceInterface) GetHTTPUpstreamServersCalls(stub func(context.Context, *v1.Instance, string) ([]client.UpstreamServer, error)) {
	fake.getHTTPUpstreamServersMutex.Lock()
	defer fake.getHTTPUpstreamServersMutex.Unlock()
	fake.GetHTTPUpstreamServersStub = stub
}

func (fake *FakeResourceServiceInterface) GetHTTPUpstreamServersArgsForCall(i int) (context.Context, *v1.Instance, string) {
	fake.getHTTPUpstreamServersMutex.RLock()
	defer fake.getHTTPUpstreamServersMutex.RUnlock()
	argsForCall := fake.getHTTPUpstreamServersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceServiceInterface) GetHTTPUpstreamServersReturns(result1 []client.UpstreamServer, result2 error) {
	fake.getHTTPUpstreamServersMutex.Lock()
	defer fake.getHTTPUpstreamServersMutex.Unlock()
	fake.GetHTTPUpstreamServersStub = nil
	fake.getHTTPUpstreamServersReturns = struct {
		result1 []client.UpstreamServer
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceServiceInterface) GetHTTPUpstreamServersReturnsOnCall(i int, result1 []client.UpstreamServer, result2 error) {
	fake.getHTTPUpstreamServersMutex.Lock()
	defer fake.getHTTPUpstreamServersMutex.Unlock()
	fake.GetHTTPUpstreamServersStub = nil
	if fake.getHTTPUpstreamServersReturnsOnCall == nil {
		fake.getHTTPUpstreamServersReturnsOnCall = make(map[int]struct {
			result1 []client.UpstreamServer
			result2 error
		})
	}
	fake.getHTTPUpstreamServersReturnsOnCall[i] = struct {
		result1 []client.UpstreamServer
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceServiceInterface) GetStreamUpstreams(arg1 context.Context, arg2 *v1.Instance) (*client.StreamUpstreams, error) {
	fake.getStreamUpstreamsMutex.Lock()
	ret, specificReturn := fake.getStreamUpstreamsReturnsOnCall[len(fake.getStreamUpstreamsArgsForCall)]
	fake.getStreamUpstreamsArgsForCall = append(fake.getStreamUpstreamsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
	}{arg1, arg2})
	stub := fake.GetStreamUpstreamsStub
	fakeReturns := fake.getStreamUpstreamsReturns
	fake.recordInvocation("GetStreamUpstreams", []interface{}{arg1, arg2})
	fake.getStreamUpstreamsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceServiceInterface) GetStreamUpstreamsCallCount() int {
	fake.getStreamUpstreamsMutex.RLock()
	defer fake.getStreamUpstreamsMutex.RUnlock()
	return len(fake.getStreamUpstreamsArgsForCall)
}

func (fake *FakeResourceServiceInterface) GetStreamUpstreamsCalls(stub func(context.Context, *v1.Instance) (*client.StreamUpstreams, error)) {
	fake.getStreamUpstreamsMutex.Lock()
	defer fake.getStreamUpstreamsMutex.Unlock()
	fake.GetStreamUpstreamsStub = stub
}

func (fake *FakeResourceServiceInterface) GetStreamUpstreamsArgsForCall(i int) (context.Context, *v1.Instance) {
	fake.getStreamUpstreamsMutex.RLock()
	defer fake.getStreamUpstreamsMutex.RUnlock()
	argsForCall := fake.getStreamUpstreamsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceServiceInterface) GetStreamUpstreamsReturns(result1 *client.StreamUpstreams, result2 error) {
	fake.getStreamUpstreamsMutex.Lock()
	defer fake.getStreamUpstreamsMutex.Unlock()
	fake.GetStreamUpstreamsStub = nil
	fake.getStreamUpstreamsReturns = struct {
		result1 *client.StreamUpstreams
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceServiceInterface) GetStreamUpstreamsReturnsOnCall(i int, result1 *client.StreamUpstreams, result2 error) {
	fake.getStreamUpstreamsMutex.Lock()
	defer fake.getStreamUpstreamsMutex.Unlock()
	fake.GetStreamUpstreamsStub = nil
	if fake.getStreamUpstreamsReturnsOnCall == nil {
		fake.getStreamUpstreamsReturnsOnCall = make(map[int]struct {
			result1 *client.StreamUpstreams
			result2 error
		})
	}
	fake.getStreamUpstreamsReturnsOnCall[i] = struct {
		result1 *client.StreamUpstreams
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceServiceInterface) GetUpstreams(arg1 context.Context, arg2 *v1.Instance) (*client.Upstreams, error) {
	fake.getUpstreamsMutex.Lock()
	ret, specificReturn := fake.getUpstreamsReturnsOnCall[len(fake.getUpstreamsArgsForCall)]
	fake.getUpstreamsArgsForCall = append(fake.getUpstreamsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
	}{arg1, arg2})
	stub := fake.GetUpstreamsStub
	fakeReturns := fake.getUpstreamsReturns
	fake.recordInvocation("GetUpstreams", []interface{}{arg1, arg2})
	fake.getUpstreamsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceServiceInterface) GetUpstreamsCallCount() int {
	fake.getUpstreamsMutex.RLock()
	defer fake.getUpstreamsMutex.RUnlock()
	return len(fake.getUpstreamsArgsForCall)
}

func (fake *FakeResourceServiceInterface) GetUpstreamsCalls(stub func(context.Context, *v1.Instance) (*client.Upstreams, error)) {
	fake.getUpstreamsMutex.Lock()
	defer fake.getUpstreamsMutex.Unlock()
	fake.GetUpstreamsStub = stub
}

func (fake *FakeResourceServiceInterface) GetUpstreamsArgsForCall(i int) (context.Context, *v1.Instance) {
	fake.getUpstreamsMutex.RLock()
	defer fake.getUpstreamsMutex.RUnlock()
	argsForCall := fake.getUpstreamsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceServiceInterface) GetUpstreamsReturns(result1 *client.Upstreams, result2 error) {
	fake.getUpstreamsMutex.Lock()
	defer fake.getUpstreamsMutex.Unlock()
	fake.GetUpstreamsStub = nil
	fake.getUpstreamsReturns = struct {
		result1 *client.Upstreams
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceServiceInterface) GetUpstreamsReturnsOnCall(i int, result1 *client.Upstreams, result2 error) {
	fake.getUpstreamsMutex.Lock()
	defer fake.getUpstreamsMutex.Unlock()
	fake.GetUpstreamsStub = nil
	if fake.getUpstreamsReturnsOnCall == nil {
		fake.getUpstreamsReturnsOnCall = make(map[int]struct {
			result1 *client.Upstreams
			result2 error
		})
	}
	fake.getUpstreamsReturnsOnCall[i] = struct {
		result1 *client.Upstreams
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceServiceInterface) Instance(arg1 string) *v1.Instance {
	fake.instanceMutex.Lock()
	ret, specificReturn := fake.instanceReturnsOnCall[len(fake.instanceArgsForCall)]
	fake.instanceArgsForCall = append(fake.instanceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.InstanceStub
	fakeReturns := fake.instanceReturns
	fake.recordInvocation("Instance", []interface{}{arg1})
	fake.instanceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceServiceInterface) InstanceCallCount() int {
	fake.instanceMutex.RLock()
	defer fake.instanceMutex.RUnlock()
	return len(fake.instanceArgsForCall)
}

func (fake *FakeResourceServiceInterface) InstanceCalls(stub func(string) *v1.Instance) {
	fake.instanceMutex.Lock()
	defer fake.instanceMutex.Unlock()
	fake.InstanceStub = stub
}

func (fake *FakeResourceServiceInterface) InstanceArgsForCall(i int) string {
	fake.instanceMutex.RLock()
	defer fake.instanceMutex.RUnlock()
	argsForCall := fake.instanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceServiceInterface) InstanceReturns(result1 *v1.Instance) {
	fake.instanceMutex.Lock()
	defer fake.instanceMutex.Unlock()
	fake.InstanceStub = nil
	fake.instanceReturns = struct {
		result1 *v1.Instance
	}{result1}
}

func (fake *FakeResourceServiceInterface) InstanceReturnsOnCall(i int, result1 *v1.Instance) {
	fake.instanceMutex.Lock()
	defer fake.instanceMutex.Unlock()
	fake.InstanceStub = nil
	if fake.instanceReturnsOnCall == nil {
		fake.instanceReturnsOnCall = make(map[int]struct {
			result1 *v1.Instance
		})
	}
	fake.instanceReturnsOnCall[i] = struct {
		result1 *v1.Instance
	}{result1}
}

func (fake *FakeResourceServiceInterface) UpdateHTTPUpstreamServers(arg1 context.Context, arg2 *v1.Instance, arg3 string, arg4 []*structpb.Struct) ([]client.UpstreamServer, []client.UpstreamServer, []client.UpstreamServer, error) {
	var arg4Copy []*structpb.Struct
	if arg4 != nil {
		arg4Copy = make([]*structpb.Struct, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateHTTPUpstreamServersMutex.Lock()
	ret, specificReturn := fake.updateHTTPUpstreamServersReturnsOnCall[len(fake.updateHTTPUpstreamServersArgsForCall)]
	fake.updateHTTPUpstreamServersArgsForCall = append(fake.updateHTTPUpstreamServersArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
		arg4 []*structpb.Struct
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.UpdateHTTPUpstreamServersStub
	fakeReturns := fake.updateHTTPUpstreamServersReturns
	fake.recordInvocation("UpdateHTTPUpstreamServers", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateHTTPUpstreamServersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeResourceServiceInterface) UpdateHTTPUpstreamServersCallCount() int {
	fake.updateHTTPUpstreamServersMutex.RLock()
	defer fake.updateHTTPUpstreamServersMutex.RUnlock()
	return len(fake.updateHTTPUpstreamServersArgsForCall)
}

func (fake *FakeResourceServiceInterface) UpdateHTTPUpstreamServersCalls(stub func(context.Context, *v1.Instance, string, []*structpb.Struct) ([]client.UpstreamServer, []client.UpstreamServer, []client.UpstreamServer, error)) {
	fake.updateHTTPUpstreamServersMutex.Lock()
	defer fake.updateHTTPUpstreamServersMutex.Unlock()
	fake.UpdateHTTPUpstreamServersStub = stub
}

func (fake *FakeResourceServiceInterface) UpdateHTTPUpstreamServersArgsForCall(i int) (context.Context, *v1.Instance, string, []*structpb.Struct) {
	fake.updateHTTPUpstreamServersMutex.RLock()
	defer fake.updateHTTPUpstreamServersMutex.RUnlock()
	argsForCall := fake.updateHTTPUpstreamServersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeResourceServiceInterface) UpdateHTTPUpstreamServersReturns(result1 []client.UpstreamServer, result2 []client.UpstreamServer, result3 []client.UpstreamServer, result4 error) {
	fake.updateHTTPUpstreamServersMutex.Lock()
	defer fake.updateHTTPUpstreamServersMutex.Unlock()
	fake.UpdateHTTPUpstreamServersStub = nil
	fake.updateHTTPUpstreamServersReturns = struct {
		result1 []client.UpstreamServer
		result2 []client.UpstreamServer
		result3 []client.UpstreamServer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResourceServiceInterface) UpdateHTTPUpstreamServersReturnsOnCall(i int, result1 []client.UpstreamServer, result2 []client.UpstreamServer, result3 []client.UpstreamServer, result4 error) {
	fake.updateHTTPUpstreamServersMutex.Lock()
	defer fake.updateHTTPUpstreamServersMutex.Unlock()
	fake.UpdateHTTPUpstreamServersStub = nil
	if fake.updateHTTPUpstreamServersReturnsOnCall == nil {
		fake.updateHTTPUpstreamServersReturnsOnCall = make(map[int]struct {
			result1 []client.UpstreamServer
			result2 []client.UpstreamServer
			result3 []client.UpstreamServer
			result4 error
		})
	}
	fake.updateHTTPUpstreamServersReturnsOnCall[i] = struct {
		result1 []client.UpstreamServer
		result2 []client.UpstreamServer
		result3 []client.UpstreamServer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResourceServiceInterface) UpdateInstances(arg1 context.Context, arg2 []*v1.Instance) *v1.Resource {
	var arg2Copy []*v1.Instance
	if arg2 != nil {
		arg2Copy = make([]*v1.Instance, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.updateInstancesMutex.Lock()
	ret, specificReturn := fake.updateInstancesReturnsOnCall[len(fake.updateInstancesArgsForCall)]
	fake.updateInstancesArgsForCall = append(fake.updateInstancesArgsForCall, struct {
		arg1 context.Context
		arg2 []*v1.Instance
	}{arg1, arg2Copy})
	stub := fake.UpdateInstancesStub
	fakeReturns := fake.updateInstancesReturns
	fake.recordInvocation("UpdateInstances", []interface{}{arg1, arg2Copy})
	fake.updateInstancesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceServiceInterface) UpdateInstancesCallCount() int {
	fake.updateInstancesMutex.RLock()
	defer fake.updateInstancesMutex.RUnlock()
	return len(fake.updateInstancesArgsForCall)
}

func (fake *FakeResourceServiceInterface) UpdateInstancesCalls(stub func(context.Context, []*v1.Instance) *v1.Resource) {
	fake.updateInstancesMutex.Lock()
	defer fake.updateInstancesMutex.Unlock()
	fake.UpdateInstancesStub = stub
}

func (fake *FakeResourceServiceInterface) UpdateInstancesArgsForCall(i int) (context.Context, []*v1.Instance) {
	fake.updateInstancesMutex.RLock()
	defer fake.updateInstancesMutex.RUnlock()
	argsForCall := fake.updateInstancesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceServiceInterface) UpdateInstancesReturns(result1 *v1.Resource) {
	fake.updateInstancesMutex.Lock()
	defer fake.updateInstancesMutex.Unlock()
	fake.UpdateInstancesStub = nil
	fake.updateInstancesReturns = struct {
		result1 *v1.Resource
	}{result1}
}

func (fake *FakeResourceServiceInterface) UpdateInstancesReturnsOnCall(i int, result1 *v1.Resource) {
	fake.updateInstancesMutex.Lock()
	defer fake.updateInstancesMutex.Unlock()
	fake.UpdateInstancesStub = nil
	if fake.updateInstancesReturnsOnCall == nil {
		fake.updateInstancesReturnsOnCall = make(map[int]struct {
			result1 *v1.Resource
		})
	}
	fake.updateInstancesReturnsOnCall[i] = struct {
		result1 *v1.Resource
	}{result1}
}

func (fake *FakeResourceServiceInterface) UpdateStreamServers(arg1 context.Context, arg2 *v1.Instance, arg3 string, arg4 []*structpb.Struct) ([]client.StreamUpstreamServer, []client.StreamUpstreamServer, []client.StreamUpstreamServer, error) {
	var arg4Copy []*structpb.Struct
	if arg4 != nil {
		arg4Copy = make([]*structpb.Struct, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateStreamServersMutex.Lock()
	ret, specificReturn := fake.updateStreamServersReturnsOnCall[len(fake.updateStreamServersArgsForCall)]
	fake.updateStreamServersArgsForCall = append(fake.updateStreamServersArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
		arg4 []*structpb.Struct
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.UpdateStreamServersStub
	fakeReturns := fake.updateStreamServersReturns
	fake.recordInvocation("UpdateStreamServers", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateStreamServersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeResourceServiceInterface) UpdateStreamServersCallCount() int {
	fake.updateStreamServersMutex.RLock()
	defer fake.updateStreamServersMutex.RUnlock()
	return len(fake.updateStreamServersArgsForCall)
}

func (fake *FakeResourceServiceInterface) UpdateStreamServersCalls(stub func(context.Context, *v1.Instance, string, []*structpb.Struct) ([]client.StreamUpstreamServer, []client.StreamUpstreamServer, []client.StreamUpstreamServer, error)) {
	fake.updateStreamServersMutex.Lock()
	defer fake.updateStreamServersMutex.Unlock()
	fake.UpdateStreamServersStub = stub
}

func (fake *FakeResourceServiceInterface) UpdateStreamServersArgsForCall(i int) (context.Context, *v1.Instance, string, []*structpb.Struct) {
	fake.updateStreamServersMutex.RLock()
	defer fake.updateStreamServersMutex.RUnlock()
	argsForCall := fake.updateStreamServersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeResourceServiceInterface) UpdateStreamServersReturns(result1 []client.StreamUpstreamServer, result2 []client.StreamUpstreamServer, result3 []client.StreamUpstreamServer, result4 error) {
	fake.updateStreamServersMutex.Lock()
	defer fake.updateStreamServersMutex.Unlock()
	fake.UpdateStreamServersStub = nil
	fake.updateStreamServersReturns = struct {
		result1 []client.StreamUpstreamServer
		result2 []client.StreamUpstreamServer
		result3 []client.StreamUpstreamServer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResourceServiceInterface) UpdateStreamServersReturnsOnCall(i int, result1 []client.StreamUpstreamServer, result2 []client.StreamUpstreamServer, result3 []client.StreamUpstreamServer, result4 error) {
	fake.updateStreamServersMutex.Lock()
	defer fake.updateStreamServersMutex.Unlock()
	fake.UpdateStreamServersStub = nil
	if fake.updateStreamServersReturnsOnCall == nil {
		fake.updateStreamServersReturnsOnCall = make(map[int]struct {
			result1 []client.StreamUpstreamServer
			result2 []client.StreamUpstreamServer
			result3 []client.StreamUpstreamServer
			result4 error
		})
	}
	fake.updateStreamServersReturnsOnCall[i] = struct {
		result1 []client.StreamUpstreamServer
		result2 []client.StreamUpstreamServer
		result3 []client.StreamUpstreamServer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeResourceServiceInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addInstancesMutex.RLock()
	defer fake.addInstancesMutex.RUnlock()
	fake.applyConfigMutex.RLock()
	defer fake.applyConfigMutex.RUnlock()
	fake.deleteInstancesMutex.RLock()
	defer fake.deleteInstancesMutex.RUnlock()
	fake.getHTTPUpstreamServersMutex.RLock()
	defer fake.getHTTPUpstreamServersMutex.RUnlock()
	fake.getStreamUpstreamsMutex.RLock()
	defer fake.getStreamUpstreamsMutex.RUnlock()
	fake.getUpstreamsMutex.RLock()
	defer fake.getUpstreamsMutex.RUnlock()
	fake.instanceMutex.RLock()
	defer fake.instanceMutex.RUnlock()
	fake.updateHTTPUpstreamServersMutex.RLock()
	defer fake.updateHTTPUpstreamServersMutex.RUnlock()
	fake.updateInstancesMutex.RLock()
	defer fake.updateInstancesMutex.RUnlock()
	fake.updateStreamServersMutex.RLock()
	defer fake.updateStreamServersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResourceServiceInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

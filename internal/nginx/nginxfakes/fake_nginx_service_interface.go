// Code generated by counterfeiter. DO NOT EDIT.
package nginxfakes

import (
	"context"
	"sync"

	v1 "github.com/nginx/agent/v3/api/grpc/mpi/v1"
	"github.com/nginx/agent/v3/internal/model"
	"github.com/nginx/nginx-plus-go-client/v3/client"
	"google.golang.org/protobuf/types/known/structpb"
)

type FakeNginxServiceInterface struct {
	ApplyConfigStub        func(context.Context, string) (*model.NginxConfigContext, error)
	applyConfigMutex       sync.RWMutex
	applyConfigArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	applyConfigReturns struct {
		result1 *model.NginxConfigContext
		result2 error
	}
	applyConfigReturnsOnCall map[int]struct {
		result1 *model.NginxConfigContext
		result2 error
	}
	GetHTTPUpstreamServersStub        func(context.Context, *v1.Instance, string) ([]client.UpstreamServer, error)
	getHTTPUpstreamServersMutex       sync.RWMutex
	getHTTPUpstreamServersArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
	}
	getHTTPUpstreamServersReturns struct {
		result1 []client.UpstreamServer
		result2 error
	}
	getHTTPUpstreamServersReturnsOnCall map[int]struct {
		result1 []client.UpstreamServer
		result2 error
	}
	GetStreamUpstreamsStub        func(context.Context, *v1.Instance) (*client.StreamUpstreams, error)
	getStreamUpstreamsMutex       sync.RWMutex
	getStreamUpstreamsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
	}
	getStreamUpstreamsReturns struct {
		result1 *client.StreamUpstreams
		result2 error
	}
	getStreamUpstreamsReturnsOnCall map[int]struct {
		result1 *client.StreamUpstreams
		result2 error
	}
	GetUpstreamsStub        func(context.Context, *v1.Instance) (*client.Upstreams, error)
	getUpstreamsMutex       sync.RWMutex
	getUpstreamsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
	}
	getUpstreamsReturns struct {
		result1 *client.Upstreams
		result2 error
	}
	getUpstreamsReturnsOnCall map[int]struct {
		result1 *client.Upstreams
		result2 error
	}
	InstanceStub        func(string) *v1.Instance
	instanceMutex       sync.RWMutex
	instanceArgsForCall []struct {
		arg1 string
	}
	instanceReturns struct {
		result1 *v1.Instance
	}
	instanceReturnsOnCall map[int]struct {
		result1 *v1.Instance
	}
	UpdateHTTPUpstreamServersStub        func(context.Context, *v1.Instance, string, []*structpb.Struct) ([]client.UpstreamServer, []client.UpstreamServer, []client.UpstreamServer, error)
	updateHTTPUpstreamServersMutex       sync.RWMutex
	updateHTTPUpstreamServersArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
		arg4 []*structpb.Struct
	}
	updateHTTPUpstreamServersReturns struct {
		result1 []client.UpstreamServer
		result2 []client.UpstreamServer
		result3 []client.UpstreamServer
		result4 error
	}
	updateHTTPUpstreamServersReturnsOnCall map[int]struct {
		result1 []client.UpstreamServer
		result2 []client.UpstreamServer
		result3 []client.UpstreamServer
		result4 error
	}
	UpdateResourceStub        func(context.Context, *v1.Resource) *v1.Resource
	updateResourceMutex       sync.RWMutex
	updateResourceArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Resource
	}
	updateResourceReturns struct {
		result1 *v1.Resource
	}
	updateResourceReturnsOnCall map[int]struct {
		result1 *v1.Resource
	}
	UpdateStreamServersStub        func(context.Context, *v1.Instance, string, []*structpb.Struct) ([]client.StreamUpstreamServer, []client.StreamUpstreamServer, []client.StreamUpstreamServer, error)
	updateStreamServersMutex       sync.RWMutex
	updateStreamServersArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
		arg4 []*structpb.Struct
	}
	updateStreamServersReturns struct {
		result1 []client.StreamUpstreamServer
		result2 []client.StreamUpstreamServer
		result3 []client.StreamUpstreamServer
		result4 error
	}
	updateStreamServersReturnsOnCall map[int]struct {
		result1 []client.StreamUpstreamServer
		result2 []client.StreamUpstreamServer
		result3 []client.StreamUpstreamServer
		result4 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNginxServiceInterface) ApplyConfig(arg1 context.Context, arg2 string) (*model.NginxConfigContext, error) {
	fake.applyConfigMutex.Lock()
	ret, specificReturn := fake.applyConfigReturnsOnCall[len(fake.applyConfigArgsForCall)]
	fake.applyConfigArgsForCall = append(fake.applyConfigArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ApplyConfigStub
	fakeReturns := fake.applyConfigReturns
	fake.recordInvocation("ApplyConfig", []interface{}{arg1, arg2})
	fake.applyConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNginxServiceInterface) ApplyConfigCallCount() int {
	fake.applyConfigMutex.RLock()
	defer fake.applyConfigMutex.RUnlock()
	return len(fake.applyConfigArgsForCall)
}

func (fake *FakeNginxServiceInterface) ApplyConfigCalls(stub func(context.Context, string) (*model.NginxConfigContext, error)) {
	fake.applyConfigMutex.Lock()
	defer fake.applyConfigMutex.Unlock()
	fake.ApplyConfigStub = stub
}

func (fake *FakeNginxServiceInterface) ApplyConfigArgsForCall(i int) (context.Context, string) {
	fake.applyConfigMutex.RLock()
	defer fake.applyConfigMutex.RUnlock()
	argsForCall := fake.applyConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNginxServiceInterface) ApplyConfigReturns(result1 *model.NginxConfigContext, result2 error) {
	fake.applyConfigMutex.Lock()
	defer fake.applyConfigMutex.Unlock()
	fake.ApplyConfigStub = nil
	fake.applyConfigReturns = struct {
		result1 *model.NginxConfigContext
		result2 error
	}{result1, result2}
}

func (fake *FakeNginxServiceInterface) ApplyConfigReturnsOnCall(i int, result1 *model.NginxConfigContext, result2 error) {
	fake.applyConfigMutex.Lock()
	defer fake.applyConfigMutex.Unlock()
	fake.ApplyConfigStub = nil
	if fake.applyConfigReturnsOnCall == nil {
		fake.applyConfigReturnsOnCall = make(map[int]struct {
			result1 *model.NginxConfigContext
			result2 error
		})
	}
	fake.applyConfigReturnsOnCall[i] = struct {
		result1 *model.NginxConfigContext
		result2 error
	}{result1, result2}
}

func (fake *FakeNginxServiceInterface) GetHTTPUpstreamServers(arg1 context.Context, arg2 *v1.Instance, arg3 string) ([]client.UpstreamServer, error) {
	fake.getHTTPUpstreamServersMutex.Lock()
	ret, specificReturn := fake.getHTTPUpstreamServersReturnsOnCall[len(fake.getHTTPUpstreamServersArgsForCall)]
	fake.getHTTPUpstreamServersArgsForCall = append(fake.getHTTPUpstreamServersArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetHTTPUpstreamServersStub
	fakeReturns := fake.getHTTPUpstreamServersReturns
	fake.recordInvocation("GetHTTPUpstreamServers", []interface{}{arg1, arg2, arg3})
	fake.getHTTPUpstreamServersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNginxServiceInterface) GetHTTPUpstreamServersCallCount() int {
	fake.getHTTPUpstreamServersMutex.RLock()
	defer fake.getHTTPUpstreamServersMutex.RUnlock()
	return len(fake.getHTTPUpstreamServersArgsForCall)
}

func (fake *FakeNginxServiceInterface) GetHTTPUpstreamServersCalls(stub func(context.Context, *v1.Instance, string) ([]client.UpstreamServer, error)) {
	fake.getHTTPUpstreamServersMutex.Lock()
	defer fake.getHTTPUpstreamServersMutex.Unlock()
	fake.GetHTTPUpstreamServersStub = stub
}

func (fake *FakeNginxServiceInterface) GetHTTPUpstreamServersArgsForCall(i int) (context.Context, *v1.Instance, string) {
	fake.getHTTPUpstreamServersMutex.RLock()
	defer fake.getHTTPUpstreamServersMutex.RUnlock()
	argsForCall := fake.getHTTPUpstreamServersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNginxServiceInterface) GetHTTPUpstreamServersReturns(result1 []client.UpstreamServer, result2 error) {
	fake.getHTTPUpstreamServersMutex.Lock()
	defer fake.getHTTPUpstreamServersMutex.Unlock()
	fake.GetHTTPUpstreamServersStub = nil
	fake.getHTTPUpstreamServersReturns = struct {
		result1 []client.UpstreamServer
		result2 error
	}{result1, result2}
}

func (fake *FakeNginxServiceInterface) GetHTTPUpstreamServersReturnsOnCall(i int, result1 []client.UpstreamServer, result2 error) {
	fake.getHTTPUpstreamServersMutex.Lock()
	defer fake.getHTTPUpstreamServersMutex.Unlock()
	fake.GetHTTPUpstreamServersStub = nil
	if fake.getHTTPUpstreamServersReturnsOnCall == nil {
		fake.getHTTPUpstreamServersReturnsOnCall = make(map[int]struct {
			result1 []client.UpstreamServer
			result2 error
		})
	}
	fake.getHTTPUpstreamServersReturnsOnCall[i] = struct {
		result1 []client.UpstreamServer
		result2 error
	}{result1, result2}
}

func (fake *FakeNginxServiceInterface) GetStreamUpstreams(arg1 context.Context, arg2 *v1.Instance) (*client.StreamUpstreams, error) {
	fake.getStreamUpstreamsMutex.Lock()
	ret, specificReturn := fake.getStreamUpstreamsReturnsOnCall[len(fake.getStreamUpstreamsArgsForCall)]
	fake.getStreamUpstreamsArgsForCall = append(fake.getStreamUpstreamsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
	}{arg1, arg2})
	stub := fake.GetStreamUpstreamsStub
	fakeReturns := fake.getStreamUpstreamsReturns
	fake.recordInvocation("GetStreamUpstreams", []interface{}{arg1, arg2})
	fake.getStreamUpstreamsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNginxServiceInterface) GetStreamUpstreamsCallCount() int {
	fake.getStreamUpstreamsMutex.RLock()
	defer fake.getStreamUpstreamsMutex.RUnlock()
	return len(fake.getStreamUpstreamsArgsForCall)
}

func (fake *FakeNginxServiceInterface) GetStreamUpstreamsCalls(stub func(context.Context, *v1.Instance) (*client.StreamUpstreams, error)) {
	fake.getStreamUpstreamsMutex.Lock()
	defer fake.getStreamUpstreamsMutex.Unlock()
	fake.GetStreamUpstreamsStub = stub
}

func (fake *FakeNginxServiceInterface) GetStreamUpstreamsArgsForCall(i int) (context.Context, *v1.Instance) {
	fake.getStreamUpstreamsMutex.RLock()
	defer fake.getStreamUpstreamsMutex.RUnlock()
	argsForCall := fake.getStreamUpstreamsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNginxServiceInterface) GetStreamUpstreamsReturns(result1 *client.StreamUpstreams, result2 error) {
	fake.getStreamUpstreamsMutex.Lock()
	defer fake.getStreamUpstreamsMutex.Unlock()
	fake.GetStreamUpstreamsStub = nil
	fake.getStreamUpstreamsReturns = struct {
		result1 *client.StreamUpstreams
		result2 error
	}{result1, result2}
}

func (fake *FakeNginxServiceInterface) GetStreamUpstreamsReturnsOnCall(i int, result1 *client.StreamUpstreams, result2 error) {
	fake.getStreamUpstreamsMutex.Lock()
	defer fake.getStreamUpstreamsMutex.Unlock()
	fake.GetStreamUpstreamsStub = nil
	if fake.getStreamUpstreamsReturnsOnCall == nil {
		fake.getStreamUpstreamsReturnsOnCall = make(map[int]struct {
			result1 *client.StreamUpstreams
			result2 error
		})
	}
	fake.getStreamUpstreamsReturnsOnCall[i] = struct {
		result1 *client.StreamUpstreams
		result2 error
	}{result1, result2}
}

func (fake *FakeNginxServiceInterface) GetUpstreams(arg1 context.Context, arg2 *v1.Instance) (*client.Upstreams, error) {
	fake.getUpstreamsMutex.Lock()
	ret, specificReturn := fake.getUpstreamsReturnsOnCall[len(fake.getUpstreamsArgsForCall)]
	fake.getUpstreamsArgsForCall = append(fake.getUpstreamsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
	}{arg1, arg2})
	stub := fake.GetUpstreamsStub
	fakeReturns := fake.getUpstreamsReturns
	fake.recordInvocation("GetUpstreams", []interface{}{arg1, arg2})
	fake.getUpstreamsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNginxServiceInterface) GetUpstreamsCallCount() int {
	fake.getUpstreamsMutex.RLock()
	defer fake.getUpstreamsMutex.RUnlock()
	return len(fake.getUpstreamsArgsForCall)
}

func (fake *FakeNginxServiceInterface) GetUpstreamsCalls(stub func(context.Context, *v1.Instance) (*client.Upstreams, error)) {
	fake.getUpstreamsMutex.Lock()
	defer fake.getUpstreamsMutex.Unlock()
	fake.GetUpstreamsStub = stub
}

func (fake *FakeNginxServiceInterface) GetUpstreamsArgsForCall(i int) (context.Context, *v1.Instance) {
	fake.getUpstreamsMutex.RLock()
	defer fake.getUpstreamsMutex.RUnlock()
	argsForCall := fake.getUpstreamsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNginxServiceInterface) GetUpstreamsReturns(result1 *client.Upstreams, result2 error) {
	fake.getUpstreamsMutex.Lock()
	defer fake.getUpstreamsMutex.Unlock()
	fake.GetUpstreamsStub = nil
	fake.getUpstreamsReturns = struct {
		result1 *client.Upstreams
		result2 error
	}{result1, result2}
}

func (fake *FakeNginxServiceInterface) GetUpstreamsReturnsOnCall(i int, result1 *client.Upstreams, result2 error) {
	fake.getUpstreamsMutex.Lock()
	defer fake.getUpstreamsMutex.Unlock()
	fake.GetUpstreamsStub = nil
	if fake.getUpstreamsReturnsOnCall == nil {
		fake.getUpstreamsReturnsOnCall = make(map[int]struct {
			result1 *client.Upstreams
			result2 error
		})
	}
	fake.getUpstreamsReturnsOnCall[i] = struct {
		result1 *client.Upstreams
		result2 error
	}{result1, result2}
}

func (fake *FakeNginxServiceInterface) Instance(arg1 string) *v1.Instance {
	fake.instanceMutex.Lock()
	ret, specificReturn := fake.instanceReturnsOnCall[len(fake.instanceArgsForCall)]
	fake.instanceArgsForCall = append(fake.instanceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.InstanceStub
	fakeReturns := fake.instanceReturns
	fake.recordInvocation("Instance", []interface{}{arg1})
	fake.instanceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNginxServiceInterface) InstanceCallCount() int {
	fake.instanceMutex.RLock()
	defer fake.instanceMutex.RUnlock()
	return len(fake.instanceArgsForCall)
}

func (fake *FakeNginxServiceInterface) InstanceCalls(stub func(string) *v1.Instance) {
	fake.instanceMutex.Lock()
	defer fake.instanceMutex.Unlock()
	fake.InstanceStub = stub
}

func (fake *FakeNginxServiceInterface) InstanceArgsForCall(i int) string {
	fake.instanceMutex.RLock()
	defer fake.instanceMutex.RUnlock()
	argsForCall := fake.instanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNginxServiceInterface) InstanceReturns(result1 *v1.Instance) {
	fake.instanceMutex.Lock()
	defer fake.instanceMutex.Unlock()
	fake.InstanceStub = nil
	fake.instanceReturns = struct {
		result1 *v1.Instance
	}{result1}
}

func (fake *FakeNginxServiceInterface) InstanceReturnsOnCall(i int, result1 *v1.Instance) {
	fake.instanceMutex.Lock()
	defer fake.instanceMutex.Unlock()
	fake.InstanceStub = nil
	if fake.instanceReturnsOnCall == nil {
		fake.instanceReturnsOnCall = make(map[int]struct {
			result1 *v1.Instance
		})
	}
	fake.instanceReturnsOnCall[i] = struct {
		result1 *v1.Instance
	}{result1}
}

func (fake *FakeNginxServiceInterface) UpdateHTTPUpstreamServers(arg1 context.Context, arg2 *v1.Instance, arg3 string, arg4 []*structpb.Struct) ([]client.UpstreamServer, []client.UpstreamServer, []client.UpstreamServer, error) {
	var arg4Copy []*structpb.Struct
	if arg4 != nil {
		arg4Copy = make([]*structpb.Struct, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateHTTPUpstreamServersMutex.Lock()
	ret, specificReturn := fake.updateHTTPUpstreamServersReturnsOnCall[len(fake.updateHTTPUpstreamServersArgsForCall)]
	fake.updateHTTPUpstreamServersArgsForCall = append(fake.updateHTTPUpstreamServersArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
		arg4 []*structpb.Struct
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.UpdateHTTPUpstreamServersStub
	fakeReturns := fake.updateHTTPUpstreamServersReturns
	fake.recordInvocation("UpdateHTTPUpstreamServers", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateHTTPUpstreamServersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeNginxServiceInterface) UpdateHTTPUpstreamServersCallCount() int {
	fake.updateHTTPUpstreamServersMutex.RLock()
	defer fake.updateHTTPUpstreamServersMutex.RUnlock()
	return len(fake.updateHTTPUpstreamServersArgsForCall)
}

func (fake *FakeNginxServiceInterface) UpdateHTTPUpstreamServersCalls(stub func(context.Context, *v1.Instance, string, []*structpb.Struct) ([]client.UpstreamServer, []client.UpstreamServer, []client.UpstreamServer, error)) {
	fake.updateHTTPUpstreamServersMutex.Lock()
	defer fake.updateHTTPUpstreamServersMutex.Unlock()
	fake.UpdateHTTPUpstreamServersStub = stub
}

func (fake *FakeNginxServiceInterface) UpdateHTTPUpstreamServersArgsForCall(i int) (context.Context, *v1.Instance, string, []*structpb.Struct) {
	fake.updateHTTPUpstreamServersMutex.RLock()
	defer fake.updateHTTPUpstreamServersMutex.RUnlock()
	argsForCall := fake.updateHTTPUpstreamServersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNginxServiceInterface) UpdateHTTPUpstreamServersReturns(result1 []client.UpstreamServer, result2 []client.UpstreamServer, result3 []client.UpstreamServer, result4 error) {
	fake.updateHTTPUpstreamServersMutex.Lock()
	defer fake.updateHTTPUpstreamServersMutex.Unlock()
	fake.UpdateHTTPUpstreamServersStub = nil
	fake.updateHTTPUpstreamServersReturns = struct {
		result1 []client.UpstreamServer
		result2 []client.UpstreamServer
		result3 []client.UpstreamServer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeNginxServiceInterface) UpdateHTTPUpstreamServersReturnsOnCall(i int, result1 []client.UpstreamServer, result2 []client.UpstreamServer, result3 []client.UpstreamServer, result4 error) {
	fake.updateHTTPUpstreamServersMutex.Lock()
	defer fake.updateHTTPUpstreamServersMutex.Unlock()
	fake.UpdateHTTPUpstreamServersStub = nil
	if fake.updateHTTPUpstreamServersReturnsOnCall == nil {
		fake.updateHTTPUpstreamServersReturnsOnCall = make(map[int]struct {
			result1 []client.UpstreamServer
			result2 []client.UpstreamServer
			result3 []client.UpstreamServer
			result4 error
		})
	}
	fake.updateHTTPUpstreamServersReturnsOnCall[i] = struct {
		result1 []client.UpstreamServer
		result2 []client.UpstreamServer
		result3 []client.UpstreamServer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeNginxServiceInterface) UpdateResource(arg1 context.Context, arg2 *v1.Resource) *v1.Resource {
	fake.updateResourceMutex.Lock()
	ret, specificReturn := fake.updateResourceReturnsOnCall[len(fake.updateResourceArgsForCall)]
	fake.updateResourceArgsForCall = append(fake.updateResourceArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Resource
	}{arg1, arg2})
	stub := fake.UpdateResourceStub
	fakeReturns := fake.updateResourceReturns
	fake.recordInvocation("UpdateResource", []interface{}{arg1, arg2})
	fake.updateResourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNginxServiceInterface) UpdateResourceCallCount() int {
	fake.updateResourceMutex.RLock()
	defer fake.updateResourceMutex.RUnlock()
	return len(fake.updateResourceArgsForCall)
}

func (fake *FakeNginxServiceInterface) UpdateResourceCalls(stub func(context.Context, *v1.Resource) *v1.Resource) {
	fake.updateResourceMutex.Lock()
	defer fake.updateResourceMutex.Unlock()
	fake.UpdateResourceStub = stub
}

func (fake *FakeNginxServiceInterface) UpdateResourceArgsForCall(i int) (context.Context, *v1.Resource) {
	fake.updateResourceMutex.RLock()
	defer fake.updateResourceMutex.RUnlock()
	argsForCall := fake.updateResourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNginxServiceInterface) UpdateResourceReturns(result1 *v1.Resource) {
	fake.updateResourceMutex.Lock()
	defer fake.updateResourceMutex.Unlock()
	fake.UpdateResourceStub = nil
	fake.updateResourceReturns = struct {
		result1 *v1.Resource
	}{result1}
}

func (fake *FakeNginxServiceInterface) UpdateResourceReturnsOnCall(i int, result1 *v1.Resource) {
	fake.updateResourceMutex.Lock()
	defer fake.updateResourceMutex.Unlock()
	fake.UpdateResourceStub = nil
	if fake.updateResourceReturnsOnCall == nil {
		fake.updateResourceReturnsOnCall = make(map[int]struct {
			result1 *v1.Resource
		})
	}
	fake.updateResourceReturnsOnCall[i] = struct {
		result1 *v1.Resource
	}{result1}
}

func (fake *FakeNginxServiceInterface) UpdateStreamServers(arg1 context.Context, arg2 *v1.Instance, arg3 string, arg4 []*structpb.Struct) ([]client.StreamUpstreamServer, []client.StreamUpstreamServer, []client.StreamUpstreamServer, error) {
	var arg4Copy []*structpb.Struct
	if arg4 != nil {
		arg4Copy = make([]*structpb.Struct, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateStreamServersMutex.Lock()
	ret, specificReturn := fake.updateStreamServersReturnsOnCall[len(fake.updateStreamServersArgsForCall)]
	fake.updateStreamServersArgsForCall = append(fake.updateStreamServersArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Instance
		arg3 string
		arg4 []*structpb.Struct
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.UpdateStreamServersStub
	fakeReturns := fake.updateStreamServersReturns
	fake.recordInvocation("UpdateStreamServers", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateStreamServersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeNginxServiceInterface) UpdateStreamServersCallCount() int {
	fake.updateStreamServersMutex.RLock()
	defer fake.updateStreamServersMutex.RUnlock()
	return len(fake.updateStreamServersArgsForCall)
}

func (fake *FakeNginxServiceInterface) UpdateStreamServersCalls(stub func(context.Context, *v1.Instance, string, []*structpb.Struct) ([]client.StreamUpstreamServer, []client.StreamUpstreamServer, []client.StreamUpstreamServer, error)) {
	fake.updateStreamServersMutex.Lock()
	defer fake.updateStreamServersMutex.Unlock()
	fake.UpdateStreamServersStub = stub
}

func (fake *FakeNginxServiceInterface) UpdateStreamServersArgsForCall(i int) (context.Context, *v1.Instance, string, []*structpb.Struct) {
	fake.updateStreamServersMutex.RLock()
	defer fake.updateStreamServersMutex.RUnlock()
	argsForCall := fake.updateStreamServersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNginxServiceInterface) UpdateStreamServersReturns(result1 []client.StreamUpstreamServer, result2 []client.StreamUpstreamServer, result3 []client.StreamUpstreamServer, result4 error) {
	fake.updateStreamServersMutex.Lock()
	defer fake.updateStreamServersMutex.Unlock()
	fake.UpdateStreamServersStub = nil
	fake.updateStreamServersReturns = struct {
		result1 []client.StreamUpstreamServer
		result2 []client.StreamUpstreamServer
		result3 []client.StreamUpstreamServer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeNginxServiceInterface) UpdateStreamServersReturnsOnCall(i int, result1 []client.StreamUpstreamServer, result2 []client.StreamUpstreamServer, result3 []client.StreamUpstreamServer, result4 error) {
	fake.updateStreamServersMutex.Lock()
	defer fake.updateStreamServersMutex.Unlock()
	fake.UpdateStreamServersStub = nil
	if fake.updateStreamServersReturnsOnCall == nil {
		fake.updateStreamServersReturnsOnCall = make(map[int]struct {
			result1 []client.StreamUpstreamServer
			result2 []client.StreamUpstreamServer
			result3 []client.StreamUpstreamServer
			result4 error
		})
	}
	fake.updateStreamServersReturnsOnCall[i] = struct {
		result1 []client.StreamUpstreamServer
		result2 []client.StreamUpstreamServer
		result3 []client.StreamUpstreamServer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeNginxServiceInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyConfigMutex.RLock()
	defer fake.applyConfigMutex.RUnlock()
	fake.getHTTPUpstreamServersMutex.RLock()
	defer fake.getHTTPUpstreamServersMutex.RUnlock()
	fake.getStreamUpstreamsMutex.RLock()
	defer fake.getStreamUpstreamsMutex.RUnlock()
	fake.getUpstreamsMutex.RLock()
	defer fake.getUpstreamsMutex.RUnlock()
	fake.instanceMutex.RLock()
	defer fake.instanceMutex.RUnlock()
	fake.updateHTTPUpstreamServersMutex.RLock()
	defer fake.updateHTTPUpstreamServersMutex.RUnlock()
	fake.updateResourceMutex.RLock()
	defer fake.updateResourceMutex.RUnlock()
	fake.updateStreamServersMutex.RLock()
	defer fake.updateStreamServersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNginxServiceInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

// Copyright (c) F5, Inc.
//
// This source code is licensed under the Apache License, Version 2.0 license found in the
// LICENSE file in the root directory of this source tree.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: mpi/v1/files.proto

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Enum to represent the possible signature algorithms used for certificates
type SignatureAlgorithm int32

const (
	// Default, unknown or unsupported algorithm
	SignatureAlgorithm_SIGNATURE_ALGORITHM_UNKNOWN SignatureAlgorithm = 0
	// MD2 with RSA (Unsupported)
	SignatureAlgorithm_MD2_WITH_RSA SignatureAlgorithm = 1
	// MD5 with RSA (Only supported for signing, not verification)
	SignatureAlgorithm_MD5_WITH_RSA SignatureAlgorithm = 2
	// SHA-1 with RSA (Only supported for signing and for verification of CRLs, CSRs, and OCSP responses)
	SignatureAlgorithm_SHA1_WITH_RSA SignatureAlgorithm = 3
	// SHA-256 with RSA
	SignatureAlgorithm_SHA256_WITH_RSA SignatureAlgorithm = 4
	// SHA-384 with RSA
	SignatureAlgorithm_SHA384_WITH_RSA SignatureAlgorithm = 5
	// SHA-512 with RSA
	SignatureAlgorithm_SHA512_WITH_RSA SignatureAlgorithm = 6
	// DSA with SHA-1 (Unsupported)
	SignatureAlgorithm_DSA_WITH_SHA1 SignatureAlgorithm = 7
	// DSA with SHA-256 (Unsupported)
	SignatureAlgorithm_DSA_WITH_SHA256 SignatureAlgorithm = 8
	// ECDSA with SHA-1 (Only supported for signing and for verification of CRLs, CSRs, and OCSP responses)
	SignatureAlgorithm_ECDSA_WITH_SHA1 SignatureAlgorithm = 9
	// ECDSA with SHA-256
	SignatureAlgorithm_ECDSA_WITH_SHA256 SignatureAlgorithm = 10
	// ECDSA with SHA-384
	SignatureAlgorithm_ECDSA_WITH_SHA384 SignatureAlgorithm = 11
	// ECDSA with SHA-512
	SignatureAlgorithm_ECDSA_WITH_SHA512 SignatureAlgorithm = 12
	// SHA-256 with RSA-PSS
	SignatureAlgorithm_SHA256_WITH_RSA_PSS SignatureAlgorithm = 13
	// SHA-384 with RSA-PSS
	SignatureAlgorithm_SHA384_WITH_RSA_PSS SignatureAlgorithm = 14
	// SHA-512 with RSA-PSS
	SignatureAlgorithm_SHA512_WITH_RSA_PSS SignatureAlgorithm = 15
	// Pure Ed25519
	SignatureAlgorithm_PURE_ED25519 SignatureAlgorithm = 16
)

// Enum value maps for SignatureAlgorithm.
var (
	SignatureAlgorithm_name = map[int32]string{
		0:  "SIGNATURE_ALGORITHM_UNKNOWN",
		1:  "MD2_WITH_RSA",
		2:  "MD5_WITH_RSA",
		3:  "SHA1_WITH_RSA",
		4:  "SHA256_WITH_RSA",
		5:  "SHA384_WITH_RSA",
		6:  "SHA512_WITH_RSA",
		7:  "DSA_WITH_SHA1",
		8:  "DSA_WITH_SHA256",
		9:  "ECDSA_WITH_SHA1",
		10: "ECDSA_WITH_SHA256",
		11: "ECDSA_WITH_SHA384",
		12: "ECDSA_WITH_SHA512",
		13: "SHA256_WITH_RSA_PSS",
		14: "SHA384_WITH_RSA_PSS",
		15: "SHA512_WITH_RSA_PSS",
		16: "PURE_ED25519",
	}
	SignatureAlgorithm_value = map[string]int32{
		"SIGNATURE_ALGORITHM_UNKNOWN": 0,
		"MD2_WITH_RSA":                1,
		"MD5_WITH_RSA":                2,
		"SHA1_WITH_RSA":               3,
		"SHA256_WITH_RSA":             4,
		"SHA384_WITH_RSA":             5,
		"SHA512_WITH_RSA":             6,
		"DSA_WITH_SHA1":               7,
		"DSA_WITH_SHA256":             8,
		"ECDSA_WITH_SHA1":             9,
		"ECDSA_WITH_SHA256":           10,
		"ECDSA_WITH_SHA384":           11,
		"ECDSA_WITH_SHA512":           12,
		"SHA256_WITH_RSA_PSS":         13,
		"SHA384_WITH_RSA_PSS":         14,
		"SHA512_WITH_RSA_PSS":         15,
		"PURE_ED25519":                16,
	}
)

func (x SignatureAlgorithm) Enum() *SignatureAlgorithm {
	p := new(SignatureAlgorithm)
	*p = x
	return p
}

func (x SignatureAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SignatureAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_mpi_v1_files_proto_enumTypes[0].Descriptor()
}

func (SignatureAlgorithm) Type() protoreflect.EnumType {
	return &file_mpi_v1_files_proto_enumTypes[0]
}

func (x SignatureAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SignatureAlgorithm.Descriptor instead.
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{0}
}

// Represents a data chunk for streaming file transfer.
// For any Stream file transfer, following assumptions should be asserted (by implementation):
// - invalid to contain more or less than one FileDataChunkHeaders
// - invalid to have FileDataChunkContents before FileDataChunkHeaders
// - invalid to have more/fewer FileDataChunkContents than FileDataChunkHeader.chunks
// - invalid to have two FileDataChunkContents with same chunk_id
// - invalid to have FileDataChunkContent with zero-length data
// - invalid to have FileDataChunk message without either header or content
// - hash of the combined contents should match FileDataChunkHeader.file_meta.hash
// - total size of the combined contents should match FileDataChunkHeader.file_meta.size
// - chunk_size should be less than the gRPC max message size
type FileDataChunk struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// meta regarding the transfer request
	Meta *MessageMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// Types that are valid to be assigned to Chunk:
	//
	//	*FileDataChunk_Header
	//	*FileDataChunk_Content
	Chunk         isFileDataChunk_Chunk `protobuf_oneof:"chunk"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileDataChunk) Reset() {
	*x = FileDataChunk{}
	mi := &file_mpi_v1_files_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileDataChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileDataChunk) ProtoMessage() {}

func (x *FileDataChunk) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileDataChunk.ProtoReflect.Descriptor instead.
func (*FileDataChunk) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{0}
}

func (x *FileDataChunk) GetMeta() *MessageMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

func (x *FileDataChunk) GetChunk() isFileDataChunk_Chunk {
	if x != nil {
		return x.Chunk
	}
	return nil
}

func (x *FileDataChunk) GetHeader() *FileDataChunkHeader {
	if x != nil {
		if x, ok := x.Chunk.(*FileDataChunk_Header); ok {
			return x.Header
		}
	}
	return nil
}

func (x *FileDataChunk) GetContent() *FileDataChunkContent {
	if x != nil {
		if x, ok := x.Chunk.(*FileDataChunk_Content); ok {
			return x.Content
		}
	}
	return nil
}

type isFileDataChunk_Chunk interface {
	isFileDataChunk_Chunk()
}

type FileDataChunk_Header struct {
	// Chunk header
	Header *FileDataChunkHeader `protobuf:"bytes,2,opt,name=header,proto3,oneof"`
}

type FileDataChunk_Content struct {
	// Chunk data
	Content *FileDataChunkContent `protobuf:"bytes,3,opt,name=content,proto3,oneof"`
}

func (*FileDataChunk_Header) isFileDataChunk_Chunk() {}

func (*FileDataChunk_Content) isFileDataChunk_Chunk() {}

// Represents a chunked resource Header
type FileDataChunkHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// meta regarding the file, help identity the file name, size, hash, perm
	// receiver should validate the hash against the combined contents
	FileMeta *FileMeta `protobuf:"bytes,1,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	// total number of chunks expected in the transfer
	Chunks uint32 `protobuf:"varint,2,opt,name=chunks,proto3" json:"chunks,omitempty"`
	// max size of individual chunks, can be undersized if EOF
	ChunkSize     uint32 `protobuf:"varint,3,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileDataChunkHeader) Reset() {
	*x = FileDataChunkHeader{}
	mi := &file_mpi_v1_files_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileDataChunkHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileDataChunkHeader) ProtoMessage() {}

func (x *FileDataChunkHeader) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileDataChunkHeader.ProtoReflect.Descriptor instead.
func (*FileDataChunkHeader) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{1}
}

func (x *FileDataChunkHeader) GetFileMeta() *FileMeta {
	if x != nil {
		return x.FileMeta
	}
	return nil
}

func (x *FileDataChunkHeader) GetChunks() uint32 {
	if x != nil {
		return x.Chunks
	}
	return 0
}

func (x *FileDataChunkHeader) GetChunkSize() uint32 {
	if x != nil {
		return x.ChunkSize
	}
	return 0
}

// Represents a chunked resource chunk
type FileDataChunkContent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// chunk id, i.e. x of y, zero-indexed
	ChunkId uint32 `protobuf:"varint,1,opt,name=chunk_id,json=chunkId,proto3" json:"chunk_id,omitempty"`
	// chunk data, should be at most chunk_size
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileDataChunkContent) Reset() {
	*x = FileDataChunkContent{}
	mi := &file_mpi_v1_files_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileDataChunkContent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileDataChunkContent) ProtoMessage() {}

func (x *FileDataChunkContent) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileDataChunkContent.ProtoReflect.Descriptor instead.
func (*FileDataChunkContent) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{2}
}

func (x *FileDataChunkContent) GetChunkId() uint32 {
	if x != nil {
		return x.ChunkId
	}
	return 0
}

func (x *FileDataChunkContent) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Represents a request payload for a file overview
type GetOverviewRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Meta-information associated with a message
	MessageMeta *MessageMeta `protobuf:"bytes,1,opt,name=message_meta,json=messageMeta,proto3" json:"message_meta,omitempty"`
	// The config version of the overview you are requesting
	ConfigVersion *ConfigVersion `protobuf:"bytes,2,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetOverviewRequest) Reset() {
	*x = GetOverviewRequest{}
	mi := &file_mpi_v1_files_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetOverviewRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetOverviewRequest) ProtoMessage() {}

func (x *GetOverviewRequest) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetOverviewRequest.ProtoReflect.Descriptor instead.
func (*GetOverviewRequest) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{3}
}

func (x *GetOverviewRequest) GetMessageMeta() *MessageMeta {
	if x != nil {
		return x.MessageMeta
	}
	return nil
}

func (x *GetOverviewRequest) GetConfigVersion() *ConfigVersion {
	if x != nil {
		return x.ConfigVersion
	}
	return nil
}

// Represents the response payload to a GetOverviewRequest, requesting a list of logically grouped files e.g. configuration payload
type GetOverviewResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file overview of an instance
	Overview      *FileOverview `protobuf:"bytes,1,opt,name=overview,proto3" json:"overview,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetOverviewResponse) Reset() {
	*x = GetOverviewResponse{}
	mi := &file_mpi_v1_files_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetOverviewResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetOverviewResponse) ProtoMessage() {}

func (x *GetOverviewResponse) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetOverviewResponse.ProtoReflect.Descriptor instead.
func (*GetOverviewResponse) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{4}
}

func (x *GetOverviewResponse) GetOverview() *FileOverview {
	if x != nil {
		return x.Overview
	}
	return nil
}

// Represents a list of logically grouped files that have changed e.g. configuration payload
type UpdateOverviewRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Meta-information associated with a message
	MessageMeta *MessageMeta `protobuf:"bytes,1,opt,name=message_meta,json=messageMeta,proto3" json:"message_meta,omitempty"`
	// The file overview of an instance
	Overview      *FileOverview `protobuf:"bytes,2,opt,name=overview,proto3" json:"overview,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOverviewRequest) Reset() {
	*x = UpdateOverviewRequest{}
	mi := &file_mpi_v1_files_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOverviewRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOverviewRequest) ProtoMessage() {}

func (x *UpdateOverviewRequest) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOverviewRequest.ProtoReflect.Descriptor instead.
func (*UpdateOverviewRequest) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{5}
}

func (x *UpdateOverviewRequest) GetMessageMeta() *MessageMeta {
	if x != nil {
		return x.MessageMeta
	}
	return nil
}

func (x *UpdateOverviewRequest) GetOverview() *FileOverview {
	if x != nil {
		return x.Overview
	}
	return nil
}

// Represents a the response from an UpdateOverviewRequest
type UpdateOverviewResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file overview with the list of files that were uploaded
	Overview      *FileOverview `protobuf:"bytes,1,opt,name=overview,proto3" json:"overview,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOverviewResponse) Reset() {
	*x = UpdateOverviewResponse{}
	mi := &file_mpi_v1_files_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOverviewResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOverviewResponse) ProtoMessage() {}

func (x *UpdateOverviewResponse) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOverviewResponse.ProtoReflect.Descriptor instead.
func (*UpdateOverviewResponse) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{6}
}

func (x *UpdateOverviewResponse) GetOverview() *FileOverview {
	if x != nil {
		return x.Overview
	}
	return nil
}

// Represents a specific configuration version associated with an instance
type ConfigVersion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The instance identifier
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// The version of the configuration
	Version       string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigVersion) Reset() {
	*x = ConfigVersion{}
	mi := &file_mpi_v1_files_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigVersion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigVersion) ProtoMessage() {}

func (x *ConfigVersion) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigVersion.ProtoReflect.Descriptor instead.
func (*ConfigVersion) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{7}
}

func (x *ConfigVersion) GetInstanceId() string {
	if x != nil {
		return x.InstanceId
	}
	return ""
}

func (x *ConfigVersion) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

// Represents a collection of files
type FileOverview struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of files
	Files []*File `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
	// The configuration version of the current set of files
	ConfigVersion *ConfigVersion `protobuf:"bytes,2,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	// The config file path of an instance
	ConfigPath    string `protobuf:"bytes,3,opt,name=config_path,json=configPath,proto3" json:"config_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileOverview) Reset() {
	*x = FileOverview{}
	mi := &file_mpi_v1_files_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileOverview) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileOverview) ProtoMessage() {}

func (x *FileOverview) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileOverview.ProtoReflect.Descriptor instead.
func (*FileOverview) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{8}
}

func (x *FileOverview) GetFiles() []*File {
	if x != nil {
		return x.Files
	}
	return nil
}

func (x *FileOverview) GetConfigVersion() *ConfigVersion {
	if x != nil {
		return x.ConfigVersion
	}
	return nil
}

func (x *FileOverview) GetConfigPath() string {
	if x != nil {
		return x.ConfigPath
	}
	return ""
}

// Represents meta data about a file
type File struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Meta information about the file, the name (including path) and hash
	FileMeta *FileMeta `protobuf:"bytes,1,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	// Unmanaged files will not be modified
	Unmanaged bool `protobuf:"varint,2,opt,name=unmanaged,proto3" json:"unmanaged,omitempty"`
	// external file source
	ExternalDataSource *ExternalDataSource `protobuf:"bytes,3,opt,name=external_data_source,json=externalDataSource,proto3,oneof" json:"external_data_source,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *File) Reset() {
	*x = File{}
	mi := &file_mpi_v1_files_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *File) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*File) ProtoMessage() {}

func (x *File) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use File.ProtoReflect.Descriptor instead.
func (*File) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{9}
}

func (x *File) GetFileMeta() *FileMeta {
	if x != nil {
		return x.FileMeta
	}
	return nil
}

func (x *File) GetUnmanaged() bool {
	if x != nil {
		return x.Unmanaged
	}
	return false
}

func (x *File) GetExternalDataSource() *ExternalDataSource {
	if x != nil {
		return x.ExternalDataSource
	}
	return nil
}

type ExternalDataSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// URL to the location of an external file
	Location      string `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExternalDataSource) Reset() {
	*x = ExternalDataSource{}
	mi := &file_mpi_v1_files_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExternalDataSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExternalDataSource) ProtoMessage() {}

func (x *ExternalDataSource) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExternalDataSource.ProtoReflect.Descriptor instead.
func (*ExternalDataSource) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{10}
}

func (x *ExternalDataSource) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

// Represents the get file request
type GetFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Meta-information associated with a message
	MessageMeta *MessageMeta `protobuf:"bytes,1,opt,name=message_meta,json=messageMeta,proto3" json:"message_meta,omitempty"`
	// Meta-information associated with the file
	FileMeta      *FileMeta `protobuf:"bytes,2,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetFileRequest) Reset() {
	*x = GetFileRequest{}
	mi := &file_mpi_v1_files_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileRequest) ProtoMessage() {}

func (x *GetFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileRequest.ProtoReflect.Descriptor instead.
func (*GetFileRequest) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{11}
}

func (x *GetFileRequest) GetMessageMeta() *MessageMeta {
	if x != nil {
		return x.MessageMeta
	}
	return nil
}

func (x *GetFileRequest) GetFileMeta() *FileMeta {
	if x != nil {
		return x.FileMeta
	}
	return nil
}

// Represents the response to a get file request
type GetFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The contents of a file
	Contents      *FileContents `protobuf:"bytes,1,opt,name=contents,proto3" json:"contents,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetFileResponse) Reset() {
	*x = GetFileResponse{}
	mi := &file_mpi_v1_files_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileResponse) ProtoMessage() {}

func (x *GetFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileResponse.ProtoReflect.Descriptor instead.
func (*GetFileResponse) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{12}
}

func (x *GetFileResponse) GetContents() *FileContents {
	if x != nil {
		return x.Contents
	}
	return nil
}

// Represents the bytes contents of the file https://protobuf.dev/programming-guides/api/#dont-encode-data-in-a-string
type FileContents struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Byte representation of a file without encoding
	Contents      []byte `protobuf:"bytes,1,opt,name=contents,proto3" json:"contents,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileContents) Reset() {
	*x = FileContents{}
	mi := &file_mpi_v1_files_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileContents) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileContents) ProtoMessage() {}

func (x *FileContents) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileContents.ProtoReflect.Descriptor instead.
func (*FileContents) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{13}
}

func (x *FileContents) GetContents() []byte {
	if x != nil {
		return x.Contents
	}
	return nil
}

// Meta information about the file, the name (including path) and hash
type FileMeta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The full path of the file
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The hash of the file contents sha256, hex encoded
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// Last modified time of the file (created time if never modified)
	ModifiedTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=modified_time,json=modifiedTime,proto3" json:"modified_time,omitempty"`
	// The permission set associated with a particular file
	Permissions string `protobuf:"bytes,4,opt,name=permissions,proto3" json:"permissions,omitempty"`
	// The size of the file in bytes
	Size int64 `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	// additional file information
	//
	// Types that are valid to be assigned to FileType:
	//
	//	*FileMeta_CertificateMeta
	FileType      isFileMeta_FileType `protobuf_oneof:"file_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileMeta) Reset() {
	*x = FileMeta{}
	mi := &file_mpi_v1_files_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileMeta) ProtoMessage() {}

func (x *FileMeta) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileMeta.ProtoReflect.Descriptor instead.
func (*FileMeta) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{14}
}

func (x *FileMeta) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *FileMeta) GetHash() string {
	if x != nil {
		return x.Hash
	}
	return ""
}

func (x *FileMeta) GetModifiedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ModifiedTime
	}
	return nil
}

func (x *FileMeta) GetPermissions() string {
	if x != nil {
		return x.Permissions
	}
	return ""
}

func (x *FileMeta) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *FileMeta) GetFileType() isFileMeta_FileType {
	if x != nil {
		return x.FileType
	}
	return nil
}

func (x *FileMeta) GetCertificateMeta() *CertificateMeta {
	if x != nil {
		if x, ok := x.FileType.(*FileMeta_CertificateMeta); ok {
			return x.CertificateMeta
		}
	}
	return nil
}

type isFileMeta_FileType interface {
	isFileMeta_FileType()
}

type FileMeta_CertificateMeta struct {
	CertificateMeta *CertificateMeta `protobuf:"bytes,6,opt,name=certificate_meta,json=certificateMeta,proto3,oneof"`
}

func (*FileMeta_CertificateMeta) isFileMeta_FileType() {}

// Represents the update file request
type UpdateFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file requested to be updated
	File *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	// The contents of a file
	Contents *FileContents `protobuf:"bytes,2,opt,name=contents,proto3" json:"contents,omitempty"`
	// Meta-information associated with a message
	MessageMeta   *MessageMeta `protobuf:"bytes,3,opt,name=message_meta,json=messageMeta,proto3" json:"message_meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateFileRequest) Reset() {
	*x = UpdateFileRequest{}
	mi := &file_mpi_v1_files_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateFileRequest) ProtoMessage() {}

func (x *UpdateFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateFileRequest.ProtoReflect.Descriptor instead.
func (*UpdateFileRequest) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{15}
}

func (x *UpdateFileRequest) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

func (x *UpdateFileRequest) GetContents() *FileContents {
	if x != nil {
		return x.Contents
	}
	return nil
}

func (x *UpdateFileRequest) GetMessageMeta() *MessageMeta {
	if x != nil {
		return x.MessageMeta
	}
	return nil
}

// Represents the response to an update file request
type UpdateFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Meta-information associated with the updated file
	FileMeta      *FileMeta `protobuf:"bytes,1,opt,name=file_meta,json=fileMeta,proto3" json:"file_meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateFileResponse) Reset() {
	*x = UpdateFileResponse{}
	mi := &file_mpi_v1_files_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateFileResponse) ProtoMessage() {}

func (x *UpdateFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateFileResponse.ProtoReflect.Descriptor instead.
func (*UpdateFileResponse) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{16}
}

func (x *UpdateFileResponse) GetFileMeta() *FileMeta {
	if x != nil {
		return x.FileMeta
	}
	return nil
}

// Define the certificate message based on https://pkg.go.dev/crypto/x509#Certificate
// and https://github.com/googleapis/googleapis/blob/005df4681b89bd204a90b76168a6dc9d9e7bf4fe/google/cloud/iot/v1/resources.proto#L341
type CertificateMeta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Serial number of the certificate, usually a unique identifier, the max length is the length of an interger
	SerialNumber string `protobuf:"bytes,1,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	// Issuer details (who issued the certificate)
	Issuer *X509Name `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// Subject details (to whom the certificate is issued)
	Subject *X509Name `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
	// Subject Alternative Names (SAN) including DNS names and IP addresses
	Sans *SubjectAlternativeNames `protobuf:"bytes,4,opt,name=sans,proto3" json:"sans,omitempty"`
	// Timestamps representing the start of certificate validity (Not Before, Not After)
	Dates *CertificateDates `protobuf:"bytes,5,opt,name=dates,proto3" json:"dates,omitempty"`
	// The algorithm used to sign the certificate (e.g., SHA256-RSA)
	SignatureAlgorithm SignatureAlgorithm `protobuf:"varint,6,opt,name=signature_algorithm,json=signatureAlgorithm,proto3,enum=mpi.v1.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// The type of public key in the certificate.
	PublicKeyAlgorithm string `protobuf:"bytes,7,opt,name=public_key_algorithm,json=publicKeyAlgorithm,proto3" json:"public_key_algorithm,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CertificateMeta) Reset() {
	*x = CertificateMeta{}
	mi := &file_mpi_v1_files_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CertificateMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CertificateMeta) ProtoMessage() {}

func (x *CertificateMeta) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CertificateMeta.ProtoReflect.Descriptor instead.
func (*CertificateMeta) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{17}
}

func (x *CertificateMeta) GetSerialNumber() string {
	if x != nil {
		return x.SerialNumber
	}
	return ""
}

func (x *CertificateMeta) GetIssuer() *X509Name {
	if x != nil {
		return x.Issuer
	}
	return nil
}

func (x *CertificateMeta) GetSubject() *X509Name {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *CertificateMeta) GetSans() *SubjectAlternativeNames {
	if x != nil {
		return x.Sans
	}
	return nil
}

func (x *CertificateMeta) GetDates() *CertificateDates {
	if x != nil {
		return x.Dates
	}
	return nil
}

func (x *CertificateMeta) GetSignatureAlgorithm() SignatureAlgorithm {
	if x != nil {
		return x.SignatureAlgorithm
	}
	return SignatureAlgorithm_SIGNATURE_ALGORITHM_UNKNOWN
}

func (x *CertificateMeta) GetPublicKeyAlgorithm() string {
	if x != nil {
		return x.PublicKeyAlgorithm
	}
	return ""
}

// Represents the dates for which a certificate is valid
type CertificateDates struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The start date that for when the certificate is valid
	NotBefore int64 `protobuf:"varint,1,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	// The end date that for when the certificate is valid
	NotAfter      int64 `protobuf:"varint,2,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CertificateDates) Reset() {
	*x = CertificateDates{}
	mi := &file_mpi_v1_files_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CertificateDates) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CertificateDates) ProtoMessage() {}

func (x *CertificateDates) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CertificateDates.ProtoReflect.Descriptor instead.
func (*CertificateDates) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{18}
}

func (x *CertificateDates) GetNotBefore() int64 {
	if x != nil {
		return x.NotBefore
	}
	return 0
}

func (x *CertificateDates) GetNotAfter() int64 {
	if x != nil {
		return x.NotAfter
	}
	return 0
}

// Represents the Subject Alternative Names for a certificate
type SubjectAlternativeNames struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of DNS names in the Subject Alternative Name (SAN) extension
	DnsNames []string `protobuf:"bytes,1,rep,name=dns_names,json=dnsNames,proto3" json:"dns_names,omitempty"`
	// List of ip addresses in the SAN extension
	IpAddresses   []string `protobuf:"bytes,2,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubjectAlternativeNames) Reset() {
	*x = SubjectAlternativeNames{}
	mi := &file_mpi_v1_files_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubjectAlternativeNames) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubjectAlternativeNames) ProtoMessage() {}

func (x *SubjectAlternativeNames) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubjectAlternativeNames.ProtoReflect.Descriptor instead.
func (*SubjectAlternativeNames) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{19}
}

func (x *SubjectAlternativeNames) GetDnsNames() []string {
	if x != nil {
		return x.DnsNames
	}
	return nil
}

func (x *SubjectAlternativeNames) GetIpAddresses() []string {
	if x != nil {
		return x.IpAddresses
	}
	return nil
}

// Represents the dates for which a certificate is valid as seen at https://pkg.go.dev/crypto/x509/pkix#Name
type X509Name struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Country name (C): Two-letter country code as per ISO 3166.
	// Must be exactly 2 characters.
	Country []string `protobuf:"bytes,1,rep,name=country,proto3" json:"country,omitempty"`
	// Organization name (O): Name of the organization.
	Organization []string `protobuf:"bytes,2,rep,name=organization,proto3" json:"organization,omitempty"`
	// Organizational Unit name (OU): Name of a subdivision or unit within the organization.
	OrganizationalUnit []string `protobuf:"bytes,3,rep,name=organizational_unit,json=organizationalUnit,proto3" json:"organizational_unit,omitempty"`
	// Locality name (L): Name of the city or locality.
	// Must be non-empty and a reasonable length (e.g., max 100 characters).
	Locality []string `protobuf:"bytes,4,rep,name=locality,proto3" json:"locality,omitempty"`
	// State or Province name (ST): Name of the state or province.
	Province []string `protobuf:"bytes,5,rep,name=province,proto3" json:"province,omitempty"`
	// Street Address (STREET): Physical street address.
	StreetAddress []string `protobuf:"bytes,6,rep,name=street_address,json=streetAddress,proto3" json:"street_address,omitempty"`
	// Postal Code (PC): Postal or ZIP code for the address.
	PostalCode []string `protobuf:"bytes,7,rep,name=postal_code,json=postalCode,proto3" json:"postal_code,omitempty"`
	// Serial Number (SN): Unique identifier or serial number.
	SerialNumber string `protobuf:"bytes,8,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	// Common Name (CN): Typically the personâ€™s or entity's full name.
	CommonName string `protobuf:"bytes,9,opt,name=common_name,json=commonName,proto3" json:"common_name,omitempty"`
	// Parsed attributes including any non-standard attributes, as specified in RFC 2253.
	// These attributes are parsed but not marshaled by this package.
	Names []*AttributeTypeAndValue `protobuf:"bytes,10,rep,name=names,proto3" json:"names,omitempty"`
	// Additional attributes to be included in the marshaled distinguished names.
	// These override any attributes with the same OID in `names`.
	ExtraNames    []*AttributeTypeAndValue `protobuf:"bytes,11,rep,name=extra_names,json=extraNames,proto3" json:"extra_names,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *X509Name) Reset() {
	*x = X509Name{}
	mi := &file_mpi_v1_files_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *X509Name) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*X509Name) ProtoMessage() {}

func (x *X509Name) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use X509Name.ProtoReflect.Descriptor instead.
func (*X509Name) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{20}
}

func (x *X509Name) GetCountry() []string {
	if x != nil {
		return x.Country
	}
	return nil
}

func (x *X509Name) GetOrganization() []string {
	if x != nil {
		return x.Organization
	}
	return nil
}

func (x *X509Name) GetOrganizationalUnit() []string {
	if x != nil {
		return x.OrganizationalUnit
	}
	return nil
}

func (x *X509Name) GetLocality() []string {
	if x != nil {
		return x.Locality
	}
	return nil
}

func (x *X509Name) GetProvince() []string {
	if x != nil {
		return x.Province
	}
	return nil
}

func (x *X509Name) GetStreetAddress() []string {
	if x != nil {
		return x.StreetAddress
	}
	return nil
}

func (x *X509Name) GetPostalCode() []string {
	if x != nil {
		return x.PostalCode
	}
	return nil
}

func (x *X509Name) GetSerialNumber() string {
	if x != nil {
		return x.SerialNumber
	}
	return ""
}

func (x *X509Name) GetCommonName() string {
	if x != nil {
		return x.CommonName
	}
	return ""
}

func (x *X509Name) GetNames() []*AttributeTypeAndValue {
	if x != nil {
		return x.Names
	}
	return nil
}

func (x *X509Name) GetExtraNames() []*AttributeTypeAndValue {
	if x != nil {
		return x.ExtraNames
	}
	return nil
}

type AttributeTypeAndValue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type (or identifier) of the attribute (e.g., OID).
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The value associated with the attribute.
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttributeTypeAndValue) Reset() {
	*x = AttributeTypeAndValue{}
	mi := &file_mpi_v1_files_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeTypeAndValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeTypeAndValue) ProtoMessage() {}

func (x *AttributeTypeAndValue) ProtoReflect() protoreflect.Message {
	mi := &file_mpi_v1_files_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeTypeAndValue.ProtoReflect.Descriptor instead.
func (*AttributeTypeAndValue) Descriptor() ([]byte, []int) {
	return file_mpi_v1_files_proto_rawDescGZIP(), []int{21}
}

func (x *AttributeTypeAndValue) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *AttributeTypeAndValue) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

var File_mpi_v1_files_proto protoreflect.FileDescriptor

const file_mpi_v1_files_proto_rawDesc = "" +
	"\n" +
	"\x12mpi/v1/files.proto\x12\x06mpi.v1\x1a\x13mpi/v1/common.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bbuf/validate/validate.proto\"\xb2\x01\n" +
	"\rFileDataChunk\x12'\n" +
	"\x04meta\x18\x01 \x01(\v2\x13.mpi.v1.MessageMetaR\x04meta\x125\n" +
	"\x06header\x18\x02 \x01(\v2\x1b.mpi.v1.FileDataChunkHeaderH\x00R\x06header\x128\n" +
	"\acontent\x18\x03 \x01(\v2\x1c.mpi.v1.FileDataChunkContentH\x00R\acontentB\a\n" +
	"\x05chunk\"\x8d\x01\n" +
	"\x13FileDataChunkHeader\x12-\n" +
	"\tfile_meta\x18\x01 \x01(\v2\x10.mpi.v1.FileMetaR\bfileMeta\x12\x1f\n" +
	"\x06chunks\x18\x02 \x01(\rB\a\xbaH\x04*\x02 \x00R\x06chunks\x12&\n" +
	"\n" +
	"chunk_size\x18\x03 \x01(\rB\a\xbaH\x04*\x02 \x00R\tchunkSize\"E\n" +
	"\x14FileDataChunkContent\x12\x19\n" +
	"\bchunk_id\x18\x01 \x01(\rR\achunkId\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\"\x8a\x01\n" +
	"\x12GetOverviewRequest\x126\n" +
	"\fmessage_meta\x18\x01 \x01(\v2\x13.mpi.v1.MessageMetaR\vmessageMeta\x12<\n" +
	"\x0econfig_version\x18\x02 \x01(\v2\x15.mpi.v1.ConfigVersionR\rconfigVersion\"G\n" +
	"\x13GetOverviewResponse\x120\n" +
	"\boverview\x18\x01 \x01(\v2\x14.mpi.v1.FileOverviewR\boverview\"\x81\x01\n" +
	"\x15UpdateOverviewRequest\x126\n" +
	"\fmessage_meta\x18\x01 \x01(\v2\x13.mpi.v1.MessageMetaR\vmessageMeta\x120\n" +
	"\boverview\x18\x02 \x01(\v2\x14.mpi.v1.FileOverviewR\boverview\"J\n" +
	"\x16UpdateOverviewResponse\x120\n" +
	"\boverview\x18\x01 \x01(\v2\x14.mpi.v1.FileOverviewR\boverview\"T\n" +
	"\rConfigVersion\x12)\n" +
	"\vinstance_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\n" +
	"instanceId\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\"\x91\x01\n" +
	"\fFileOverview\x12\"\n" +
	"\x05files\x18\x01 \x03(\v2\f.mpi.v1.FileR\x05files\x12<\n" +
	"\x0econfig_version\x18\x02 \x01(\v2\x15.mpi.v1.ConfigVersionR\rconfigVersion\x12\x1f\n" +
	"\vconfig_path\x18\x03 \x01(\tR\n" +
	"configPath\"\xbf\x01\n" +
	"\x04File\x12-\n" +
	"\tfile_meta\x18\x01 \x01(\v2\x10.mpi.v1.FileMetaR\bfileMeta\x12\x1c\n" +
	"\tunmanaged\x18\x02 \x01(\bR\tunmanaged\x12Q\n" +
	"\x14external_data_source\x18\x03 \x01(\v2\x1a.mpi.v1.ExternalDataSourceH\x00R\x12externalDataSource\x88\x01\x01B\x17\n" +
	"\x15_external_data_source\"0\n" +
	"\x12ExternalDataSource\x12\x1a\n" +
	"\blocation\x18\x01 \x01(\tR\blocation\"w\n" +
	"\x0eGetFileRequest\x126\n" +
	"\fmessage_meta\x18\x01 \x01(\v2\x13.mpi.v1.MessageMetaR\vmessageMeta\x12-\n" +
	"\tfile_meta\x18\x02 \x01(\v2\x10.mpi.v1.FileMetaR\bfileMeta\"C\n" +
	"\x0fGetFileResponse\x120\n" +
	"\bcontents\x18\x01 \x01(\v2\x14.mpi.v1.FileContentsR\bcontents\"*\n" +
	"\fFileContents\x12\x1a\n" +
	"\bcontents\x18\x01 \x01(\fR\bcontents\"\xa2\x02\n" +
	"\bFileMeta\x12\x1c\n" +
	"\x04name\x18\x01 \x01(\tB\b\xbaH\x05r\x03:\x01/R\x04name\x12\x12\n" +
	"\x04hash\x18\x02 \x01(\tR\x04hash\x12I\n" +
	"\rmodified_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampB\b\xbaH\x05\xb2\x01\x028\x01R\fmodifiedTime\x122\n" +
	"\vpermissions\x18\x04 \x01(\tB\x10\xbaH\rr\v2\t0[0-7]{3}R\vpermissions\x12\x12\n" +
	"\x04size\x18\x05 \x01(\x03R\x04size\x12D\n" +
	"\x10certificate_meta\x18\x06 \x01(\v2\x17.mpi.v1.CertificateMetaH\x00R\x0fcertificateMetaB\v\n" +
	"\tfile_type\"\x9f\x01\n" +
	"\x11UpdateFileRequest\x12 \n" +
	"\x04file\x18\x01 \x01(\v2\f.mpi.v1.FileR\x04file\x120\n" +
	"\bcontents\x18\x02 \x01(\v2\x14.mpi.v1.FileContentsR\bcontents\x126\n" +
	"\fmessage_meta\x18\x03 \x01(\v2\x13.mpi.v1.MessageMetaR\vmessageMeta\"C\n" +
	"\x12UpdateFileResponse\x12-\n" +
	"\tfile_meta\x18\x01 \x01(\v2\x10.mpi.v1.FileMetaR\bfileMeta\"\xf9\x02\n" +
	"\x0fCertificateMeta\x12,\n" +
	"\rserial_number\x18\x01 \x01(\tB\a\xbaH\x04r\x02\x10\x00R\fserialNumber\x12(\n" +
	"\x06issuer\x18\x02 \x01(\v2\x10.mpi.v1.X509NameR\x06issuer\x12*\n" +
	"\asubject\x18\x03 \x01(\v2\x10.mpi.v1.X509NameR\asubject\x123\n" +
	"\x04sans\x18\x04 \x01(\v2\x1f.mpi.v1.SubjectAlternativeNamesR\x04sans\x12.\n" +
	"\x05dates\x18\x05 \x01(\v2\x18.mpi.v1.CertificateDatesR\x05dates\x12K\n" +
	"\x13signature_algorithm\x18\x06 \x01(\x0e2\x1a.mpi.v1.SignatureAlgorithmR\x12signatureAlgorithm\x120\n" +
	"\x14public_key_algorithm\x18\a \x01(\tR\x12publicKeyAlgorithm\"N\n" +
	"\x10CertificateDates\x12\x1d\n" +
	"\n" +
	"not_before\x18\x01 \x01(\x03R\tnotBefore\x12\x1b\n" +
	"\tnot_after\x18\x02 \x01(\x03R\bnotAfter\"Y\n" +
	"\x17SubjectAlternativeNames\x12\x1b\n" +
	"\tdns_names\x18\x01 \x03(\tR\bdnsNames\x12!\n" +
	"\fip_addresses\x18\x02 \x03(\tR\vipAddresses\"\x98\x04\n" +
	"\bX509Name\x12(\n" +
	"\acountry\x18\x01 \x03(\tB\x0e\xbaH\v\x92\x01\b\"\x06r\x04\x10\x02\x18\x02R\acountry\x120\n" +
	"\forganization\x18\x02 \x03(\tB\f\xbaH\t\x92\x01\x06\"\x04r\x02\x10\x01R\forganization\x12=\n" +
	"\x13organizational_unit\x18\x03 \x03(\tB\f\xbaH\t\x92\x01\x06\"\x04r\x02\x10\x01R\x12organizationalUnit\x12(\n" +
	"\blocality\x18\x04 \x03(\tB\f\xbaH\t\x92\x01\x06\"\x04r\x02\x10\x01R\blocality\x12(\n" +
	"\bprovince\x18\x05 \x03(\tB\f\xbaH\t\x92\x01\x06\"\x04r\x02\x10\x01R\bprovince\x123\n" +
	"\x0estreet_address\x18\x06 \x03(\tB\f\xbaH\t\x92\x01\x06\"\x04r\x02\x10\x01R\rstreetAddress\x12-\n" +
	"\vpostal_code\x18\a \x03(\tB\f\xbaH\t\x92\x01\x06\"\x04r\x02\x10\x01R\n" +
	"postalCode\x12#\n" +
	"\rserial_number\x18\b \x01(\tR\fserialNumber\x12\x1f\n" +
	"\vcommon_name\x18\t \x01(\tR\n" +
	"commonName\x123\n" +
	"\x05names\x18\n" +
	" \x03(\v2\x1d.mpi.v1.AttributeTypeAndValueR\x05names\x12>\n" +
	"\vextra_names\x18\v \x03(\v2\x1d.mpi.v1.AttributeTypeAndValueR\n" +
	"extraNames\"S\n" +
	"\x15AttributeTypeAndValue\x12\x1b\n" +
	"\x04type\x18\x01 \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x04type\x12\x1d\n" +
	"\x05value\x18\x02 \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x05value*\x8a\x03\n" +
	"\x12SignatureAlgorithm\x12\x1f\n" +
	"\x1bSIGNATURE_ALGORITHM_UNKNOWN\x10\x00\x12\x10\n" +
	"\fMD2_WITH_RSA\x10\x01\x12\x10\n" +
	"\fMD5_WITH_RSA\x10\x02\x12\x11\n" +
	"\rSHA1_WITH_RSA\x10\x03\x12\x13\n" +
	"\x0fSHA256_WITH_RSA\x10\x04\x12\x13\n" +
	"\x0fSHA384_WITH_RSA\x10\x05\x12\x13\n" +
	"\x0fSHA512_WITH_RSA\x10\x06\x12\x11\n" +
	"\rDSA_WITH_SHA1\x10\a\x12\x13\n" +
	"\x0fDSA_WITH_SHA256\x10\b\x12\x13\n" +
	"\x0fECDSA_WITH_SHA1\x10\t\x12\x15\n" +
	"\x11ECDSA_WITH_SHA256\x10\n" +
	"\x12\x15\n" +
	"\x11ECDSA_WITH_SHA384\x10\v\x12\x15\n" +
	"\x11ECDSA_WITH_SHA512\x10\f\x12\x17\n" +
	"\x13SHA256_WITH_RSA_PSS\x10\r\x12\x17\n" +
	"\x13SHA384_WITH_RSA_PSS\x10\x0e\x12\x17\n" +
	"\x13SHA512_WITH_RSA_PSS\x10\x0f\x12\x10\n" +
	"\fPURE_ED25519\x10\x102\xbe\x03\n" +
	"\vFileService\x12H\n" +
	"\vGetOverview\x12\x1a.mpi.v1.GetOverviewRequest\x1a\x1b.mpi.v1.GetOverviewResponse\"\x00\x12Q\n" +
	"\x0eUpdateOverview\x12\x1d.mpi.v1.UpdateOverviewRequest\x1a\x1e.mpi.v1.UpdateOverviewResponse\"\x00\x12<\n" +
	"\aGetFile\x12\x16.mpi.v1.GetFileRequest\x1a\x17.mpi.v1.GetFileResponse\"\x00\x12E\n" +
	"\n" +
	"UpdateFile\x12\x19.mpi.v1.UpdateFileRequest\x1a\x1a.mpi.v1.UpdateFileResponse\"\x00\x12B\n" +
	"\rGetFileStream\x12\x16.mpi.v1.GetFileRequest\x1a\x15.mpi.v1.FileDataChunk\"\x000\x01\x12I\n" +
	"\x10UpdateFileStream\x12\x15.mpi.v1.FileDataChunk\x1a\x1a.mpi.v1.UpdateFileResponse\"\x00(\x01B\bZ\x06mpi/v1b\x06proto3"

var (
	file_mpi_v1_files_proto_rawDescOnce sync.Once
	file_mpi_v1_files_proto_rawDescData []byte
)

func file_mpi_v1_files_proto_rawDescGZIP() []byte {
	file_mpi_v1_files_proto_rawDescOnce.Do(func() {
		file_mpi_v1_files_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_mpi_v1_files_proto_rawDesc), len(file_mpi_v1_files_proto_rawDesc)))
	})
	return file_mpi_v1_files_proto_rawDescData
}

var file_mpi_v1_files_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_mpi_v1_files_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_mpi_v1_files_proto_goTypes = []any{
	(SignatureAlgorithm)(0),         // 0: mpi.v1.SignatureAlgorithm
	(*FileDataChunk)(nil),           // 1: mpi.v1.FileDataChunk
	(*FileDataChunkHeader)(nil),     // 2: mpi.v1.FileDataChunkHeader
	(*FileDataChunkContent)(nil),    // 3: mpi.v1.FileDataChunkContent
	(*GetOverviewRequest)(nil),      // 4: mpi.v1.GetOverviewRequest
	(*GetOverviewResponse)(nil),     // 5: mpi.v1.GetOverviewResponse
	(*UpdateOverviewRequest)(nil),   // 6: mpi.v1.UpdateOverviewRequest
	(*UpdateOverviewResponse)(nil),  // 7: mpi.v1.UpdateOverviewResponse
	(*ConfigVersion)(nil),           // 8: mpi.v1.ConfigVersion
	(*FileOverview)(nil),            // 9: mpi.v1.FileOverview
	(*File)(nil),                    // 10: mpi.v1.File
	(*ExternalDataSource)(nil),      // 11: mpi.v1.ExternalDataSource
	(*GetFileRequest)(nil),          // 12: mpi.v1.GetFileRequest
	(*GetFileResponse)(nil),         // 13: mpi.v1.GetFileResponse
	(*FileContents)(nil),            // 14: mpi.v1.FileContents
	(*FileMeta)(nil),                // 15: mpi.v1.FileMeta
	(*UpdateFileRequest)(nil),       // 16: mpi.v1.UpdateFileRequest
	(*UpdateFileResponse)(nil),      // 17: mpi.v1.UpdateFileResponse
	(*CertificateMeta)(nil),         // 18: mpi.v1.CertificateMeta
	(*CertificateDates)(nil),        // 19: mpi.v1.CertificateDates
	(*SubjectAlternativeNames)(nil), // 20: mpi.v1.SubjectAlternativeNames
	(*X509Name)(nil),                // 21: mpi.v1.X509Name
	(*AttributeTypeAndValue)(nil),   // 22: mpi.v1.AttributeTypeAndValue
	(*MessageMeta)(nil),             // 23: mpi.v1.MessageMeta
	(*timestamppb.Timestamp)(nil),   // 24: google.protobuf.Timestamp
}
var file_mpi_v1_files_proto_depIdxs = []int32{
	23, // 0: mpi.v1.FileDataChunk.meta:type_name -> mpi.v1.MessageMeta
	2,  // 1: mpi.v1.FileDataChunk.header:type_name -> mpi.v1.FileDataChunkHeader
	3,  // 2: mpi.v1.FileDataChunk.content:type_name -> mpi.v1.FileDataChunkContent
	15, // 3: mpi.v1.FileDataChunkHeader.file_meta:type_name -> mpi.v1.FileMeta
	23, // 4: mpi.v1.GetOverviewRequest.message_meta:type_name -> mpi.v1.MessageMeta
	8,  // 5: mpi.v1.GetOverviewRequest.config_version:type_name -> mpi.v1.ConfigVersion
	9,  // 6: mpi.v1.GetOverviewResponse.overview:type_name -> mpi.v1.FileOverview
	23, // 7: mpi.v1.UpdateOverviewRequest.message_meta:type_name -> mpi.v1.MessageMeta
	9,  // 8: mpi.v1.UpdateOverviewRequest.overview:type_name -> mpi.v1.FileOverview
	9,  // 9: mpi.v1.UpdateOverviewResponse.overview:type_name -> mpi.v1.FileOverview
	10, // 10: mpi.v1.FileOverview.files:type_name -> mpi.v1.File
	8,  // 11: mpi.v1.FileOverview.config_version:type_name -> mpi.v1.ConfigVersion
	15, // 12: mpi.v1.File.file_meta:type_name -> mpi.v1.FileMeta
	11, // 13: mpi.v1.File.external_data_source:type_name -> mpi.v1.ExternalDataSource
	23, // 14: mpi.v1.GetFileRequest.message_meta:type_name -> mpi.v1.MessageMeta
	15, // 15: mpi.v1.GetFileRequest.file_meta:type_name -> mpi.v1.FileMeta
	14, // 16: mpi.v1.GetFileResponse.contents:type_name -> mpi.v1.FileContents
	24, // 17: mpi.v1.FileMeta.modified_time:type_name -> google.protobuf.Timestamp
	18, // 18: mpi.v1.FileMeta.certificate_meta:type_name -> mpi.v1.CertificateMeta
	10, // 19: mpi.v1.UpdateFileRequest.file:type_name -> mpi.v1.File
	14, // 20: mpi.v1.UpdateFileRequest.contents:type_name -> mpi.v1.FileContents
	23, // 21: mpi.v1.UpdateFileRequest.message_meta:type_name -> mpi.v1.MessageMeta
	15, // 22: mpi.v1.UpdateFileResponse.file_meta:type_name -> mpi.v1.FileMeta
	21, // 23: mpi.v1.CertificateMeta.issuer:type_name -> mpi.v1.X509Name
	21, // 24: mpi.v1.CertificateMeta.subject:type_name -> mpi.v1.X509Name
	20, // 25: mpi.v1.CertificateMeta.sans:type_name -> mpi.v1.SubjectAlternativeNames
	19, // 26: mpi.v1.CertificateMeta.dates:type_name -> mpi.v1.CertificateDates
	0,  // 27: mpi.v1.CertificateMeta.signature_algorithm:type_name -> mpi.v1.SignatureAlgorithm
	22, // 28: mpi.v1.X509Name.names:type_name -> mpi.v1.AttributeTypeAndValue
	22, // 29: mpi.v1.X509Name.extra_names:type_name -> mpi.v1.AttributeTypeAndValue
	4,  // 30: mpi.v1.FileService.GetOverview:input_type -> mpi.v1.GetOverviewRequest
	6,  // 31: mpi.v1.FileService.UpdateOverview:input_type -> mpi.v1.UpdateOverviewRequest
	12, // 32: mpi.v1.FileService.GetFile:input_type -> mpi.v1.GetFileRequest
	16, // 33: mpi.v1.FileService.UpdateFile:input_type -> mpi.v1.UpdateFileRequest
	12, // 34: mpi.v1.FileService.GetFileStream:input_type -> mpi.v1.GetFileRequest
	1,  // 35: mpi.v1.FileService.UpdateFileStream:input_type -> mpi.v1.FileDataChunk
	5,  // 36: mpi.v1.FileService.GetOverview:output_type -> mpi.v1.GetOverviewResponse
	7,  // 37: mpi.v1.FileService.UpdateOverview:output_type -> mpi.v1.UpdateOverviewResponse
	13, // 38: mpi.v1.FileService.GetFile:output_type -> mpi.v1.GetFileResponse
	17, // 39: mpi.v1.FileService.UpdateFile:output_type -> mpi.v1.UpdateFileResponse
	1,  // 40: mpi.v1.FileService.GetFileStream:output_type -> mpi.v1.FileDataChunk
	17, // 41: mpi.v1.FileService.UpdateFileStream:output_type -> mpi.v1.UpdateFileResponse
	36, // [36:42] is the sub-list for method output_type
	30, // [30:36] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_mpi_v1_files_proto_init() }
func file_mpi_v1_files_proto_init() {
	if File_mpi_v1_files_proto != nil {
		return
	}
	file_mpi_v1_common_proto_init()
	file_mpi_v1_files_proto_msgTypes[0].OneofWrappers = []any{
		(*FileDataChunk_Header)(nil),
		(*FileDataChunk_Content)(nil),
	}
	file_mpi_v1_files_proto_msgTypes[9].OneofWrappers = []any{}
	file_mpi_v1_files_proto_msgTypes[14].OneofWrappers = []any{
		(*FileMeta_CertificateMeta)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_mpi_v1_files_proto_rawDesc), len(file_mpi_v1_files_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   22,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_mpi_v1_files_proto_goTypes,
		DependencyIndexes: file_mpi_v1_files_proto_depIdxs,
		EnumInfos:         file_mpi_v1_files_proto_enumTypes,
		MessageInfos:      file_mpi_v1_files_proto_msgTypes,
	}.Build()
	File_mpi_v1_files_proto = out.File
	file_mpi_v1_files_proto_goTypes = nil
	file_mpi_v1_files_proto_depIdxs = nil
}

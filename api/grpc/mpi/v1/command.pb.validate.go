// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: mpi/v1/command.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectionRequestMultiError, or nil if none found.
func (m *CreateConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMessageMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessageMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionRequestValidationError{
				field:  "MessageMeta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionRequestValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectionRequestMultiError(errors)
	}

	return nil
}

// CreateConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectionRequestMultiError) AllErrors() []error { return m }

// CreateConnectionRequestValidationError is the validation error returned by
// CreateConnectionRequest.Validate if the designated constraints aren't met.
type CreateConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectionRequestValidationError) ErrorName() string {
	return "CreateConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectionRequestValidationError{}

// Validate checks the field values on Resource with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMultiError, or nil
// if none found.
func (m *Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceId

	for idx, item := range m.GetInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  fmt.Sprintf("Instances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Info.(type) {
	case *Resource_HostInfo:
		if v == nil {
			err := ResourceValidationError{
				field:  "Info",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHostInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "HostInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "HostInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHostInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "HostInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_ContainerInfo:
		if v == nil {
			err := ResourceValidationError{
				field:  "Info",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetContainerInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "ContainerInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "ContainerInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetContainerInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "ContainerInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ResourceMultiError(errors)
	}

	return nil
}

// ResourceMultiError is an error wrapping multiple validation errors returned
// by Resource.ValidateAll() if the designated constraints aren't met.
type ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMultiError) AllErrors() []error { return m }

// ResourceValidationError is the validation error returned by
// Resource.Validate if the designated constraints aren't met.
type ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceValidationError) ErrorName() string { return "ResourceValidationError" }

// Error satisfies the builtin error interface
func (e ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceValidationError{}

// Validate checks the field values on HostInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HostInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HostInfoMultiError, or nil
// if none found.
func (m *HostInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *HostInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostId

	// no validation rules for Hostname

	if all {
		switch v := interface{}(m.GetReleaseInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HostInfoValidationError{
					field:  "ReleaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HostInfoValidationError{
					field:  "ReleaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaseInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HostInfoValidationError{
				field:  "ReleaseInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HostInfoMultiError(errors)
	}

	return nil
}

// HostInfoMultiError is an error wrapping multiple validation errors returned
// by HostInfo.ValidateAll() if the designated constraints aren't met.
type HostInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostInfoMultiError) AllErrors() []error { return m }

// HostInfoValidationError is the validation error returned by
// HostInfo.Validate if the designated constraints aren't met.
type HostInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostInfoValidationError) ErrorName() string { return "HostInfoValidationError" }

// Error satisfies the builtin error interface
func (e HostInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostInfoValidationError{}

// Validate checks the field values on ReleaseInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseInfoMultiError, or
// nil if none found.
func (m *ReleaseInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Codename

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for VersionId

	// no validation rules for Version

	if len(errors) > 0 {
		return ReleaseInfoMultiError(errors)
	}

	return nil
}

// ReleaseInfoMultiError is an error wrapping multiple validation errors
// returned by ReleaseInfo.ValidateAll() if the designated constraints aren't met.
type ReleaseInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseInfoMultiError) AllErrors() []error { return m }

// ReleaseInfoValidationError is the validation error returned by
// ReleaseInfo.Validate if the designated constraints aren't met.
type ReleaseInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseInfoValidationError) ErrorName() string { return "ReleaseInfoValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseInfoValidationError{}

// Validate checks the field values on ContainerInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContainerInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerInfoMultiError, or
// nil if none found.
func (m *ContainerInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContainerId

	// no validation rules for Hostname

	if all {
		switch v := interface{}(m.GetReleaseInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerInfoValidationError{
					field:  "ReleaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerInfoValidationError{
					field:  "ReleaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaseInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerInfoValidationError{
				field:  "ReleaseInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContainerInfoMultiError(errors)
	}

	return nil
}

// ContainerInfoMultiError is an error wrapping multiple validation errors
// returned by ContainerInfo.ValidateAll() if the designated constraints
// aren't met.
type ContainerInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerInfoMultiError) AllErrors() []error { return m }

// ContainerInfoValidationError is the validation error returned by
// ContainerInfo.Validate if the designated constraints aren't met.
type ContainerInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerInfoValidationError) ErrorName() string { return "ContainerInfoValidationError" }

// Error satisfies the builtin error interface
func (e ContainerInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerInfoValidationError{}

// Validate checks the field values on CreateConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectionResponseMultiError, or nil if none found.
func (m *CreateConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionResponseValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAgentConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "AgentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "AgentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAgentConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionResponseValidationError{
				field:  "AgentConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectionResponseMultiError(errors)
	}

	return nil
}

// CreateConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectionResponseMultiError) AllErrors() []error { return m }

// CreateConnectionResponseValidationError is the validation error returned by
// CreateConnectionResponse.Validate if the designated constraints aren't met.
type CreateConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectionResponseValidationError) ErrorName() string {
	return "CreateConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectionResponseValidationError{}

// Validate checks the field values on UpdateDataPlaneStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDataPlaneStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDataPlaneStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDataPlaneStatusRequestMultiError, or nil if none found.
func (m *UpdateDataPlaneStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDataPlaneStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMessageMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDataPlaneStatusRequestValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDataPlaneStatusRequestValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessageMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDataPlaneStatusRequestValidationError{
				field:  "MessageMeta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDataPlaneStatusRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDataPlaneStatusRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDataPlaneStatusRequestValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDataPlaneStatusRequestMultiError(errors)
	}

	return nil
}

// UpdateDataPlaneStatusRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDataPlaneStatusRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDataPlaneStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDataPlaneStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDataPlaneStatusRequestMultiError) AllErrors() []error { return m }

// UpdateDataPlaneStatusRequestValidationError is the validation error returned
// by UpdateDataPlaneStatusRequest.Validate if the designated constraints
// aren't met.
type UpdateDataPlaneStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDataPlaneStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDataPlaneStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDataPlaneStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDataPlaneStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDataPlaneStatusRequestValidationError) ErrorName() string {
	return "UpdateDataPlaneStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDataPlaneStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDataPlaneStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDataPlaneStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDataPlaneStatusRequestValidationError{}

// Validate checks the field values on UpdateDataPlaneStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDataPlaneStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDataPlaneStatusResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDataPlaneStatusResponseMultiError, or nil if none found.
func (m *UpdateDataPlaneStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDataPlaneStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateDataPlaneStatusResponseMultiError(errors)
	}

	return nil
}

// UpdateDataPlaneStatusResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDataPlaneStatusResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateDataPlaneStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDataPlaneStatusResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDataPlaneStatusResponseMultiError) AllErrors() []error { return m }

// UpdateDataPlaneStatusResponseValidationError is the validation error
// returned by UpdateDataPlaneStatusResponse.Validate if the designated
// constraints aren't met.
type UpdateDataPlaneStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDataPlaneStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDataPlaneStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDataPlaneStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDataPlaneStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDataPlaneStatusResponseValidationError) ErrorName() string {
	return "UpdateDataPlaneStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDataPlaneStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDataPlaneStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDataPlaneStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDataPlaneStatusResponseValidationError{}

// Validate checks the field values on InstanceHealth with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceHealth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceHealth with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceHealthMultiError,
// or nil if none found.
func (m *InstanceHealth) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceHealth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for InstanceHealthStatus

	// no validation rules for Description

	if len(errors) > 0 {
		return InstanceHealthMultiError(errors)
	}

	return nil
}

// InstanceHealthMultiError is an error wrapping multiple validation errors
// returned by InstanceHealth.ValidateAll() if the designated constraints
// aren't met.
type InstanceHealthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceHealthMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceHealthMultiError) AllErrors() []error { return m }

// InstanceHealthValidationError is the validation error returned by
// InstanceHealth.Validate if the designated constraints aren't met.
type InstanceHealthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceHealthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceHealthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceHealthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceHealthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceHealthValidationError) ErrorName() string { return "InstanceHealthValidationError" }

// Error satisfies the builtin error interface
func (e InstanceHealthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceHealth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceHealthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceHealthValidationError{}

// Validate checks the field values on UpdateDataPlaneHealthRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDataPlaneHealthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDataPlaneHealthRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDataPlaneHealthRequestMultiError, or nil if none found.
func (m *UpdateDataPlaneHealthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDataPlaneHealthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMessageMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDataPlaneHealthRequestValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDataPlaneHealthRequestValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessageMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDataPlaneHealthRequestValidationError{
				field:  "MessageMeta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInstanceHealths() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDataPlaneHealthRequestValidationError{
						field:  fmt.Sprintf("InstanceHealths[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDataPlaneHealthRequestValidationError{
						field:  fmt.Sprintf("InstanceHealths[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDataPlaneHealthRequestValidationError{
					field:  fmt.Sprintf("InstanceHealths[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDataPlaneHealthRequestMultiError(errors)
	}

	return nil
}

// UpdateDataPlaneHealthRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDataPlaneHealthRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDataPlaneHealthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDataPlaneHealthRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDataPlaneHealthRequestMultiError) AllErrors() []error { return m }

// UpdateDataPlaneHealthRequestValidationError is the validation error returned
// by UpdateDataPlaneHealthRequest.Validate if the designated constraints
// aren't met.
type UpdateDataPlaneHealthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDataPlaneHealthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDataPlaneHealthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDataPlaneHealthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDataPlaneHealthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDataPlaneHealthRequestValidationError) ErrorName() string {
	return "UpdateDataPlaneHealthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDataPlaneHealthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDataPlaneHealthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDataPlaneHealthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDataPlaneHealthRequestValidationError{}

// Validate checks the field values on UpdateDataPlaneHealthResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDataPlaneHealthResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDataPlaneHealthResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDataPlaneHealthResponseMultiError, or nil if none found.
func (m *UpdateDataPlaneHealthResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDataPlaneHealthResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateDataPlaneHealthResponseMultiError(errors)
	}

	return nil
}

// UpdateDataPlaneHealthResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDataPlaneHealthResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateDataPlaneHealthResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDataPlaneHealthResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDataPlaneHealthResponseMultiError) AllErrors() []error { return m }

// UpdateDataPlaneHealthResponseValidationError is the validation error
// returned by UpdateDataPlaneHealthResponse.Validate if the designated
// constraints aren't met.
type UpdateDataPlaneHealthResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDataPlaneHealthResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDataPlaneHealthResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDataPlaneHealthResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDataPlaneHealthResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDataPlaneHealthResponseValidationError) ErrorName() string {
	return "UpdateDataPlaneHealthResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDataPlaneHealthResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDataPlaneHealthResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDataPlaneHealthResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDataPlaneHealthResponseValidationError{}

// Validate checks the field values on DataPlaneResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DataPlaneResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataPlaneResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DataPlaneResponseMultiError, or nil if none found.
func (m *DataPlaneResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DataPlaneResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMessageMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataPlaneResponseValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataPlaneResponseValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessageMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataPlaneResponseValidationError{
				field:  "MessageMeta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCommandResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataPlaneResponseValidationError{
					field:  "CommandResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataPlaneResponseValidationError{
					field:  "CommandResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommandResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataPlaneResponseValidationError{
				field:  "CommandResponse",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstanceId

	if len(errors) > 0 {
		return DataPlaneResponseMultiError(errors)
	}

	return nil
}

// DataPlaneResponseMultiError is an error wrapping multiple validation errors
// returned by DataPlaneResponse.ValidateAll() if the designated constraints
// aren't met.
type DataPlaneResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataPlaneResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataPlaneResponseMultiError) AllErrors() []error { return m }

// DataPlaneResponseValidationError is the validation error returned by
// DataPlaneResponse.Validate if the designated constraints aren't met.
type DataPlaneResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataPlaneResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataPlaneResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataPlaneResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataPlaneResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataPlaneResponseValidationError) ErrorName() string {
	return "DataPlaneResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DataPlaneResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataPlaneResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataPlaneResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataPlaneResponseValidationError{}

// Validate checks the field values on ManagementPlaneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ManagementPlaneRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManagementPlaneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManagementPlaneRequestMultiError, or nil if none found.
func (m *ManagementPlaneRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ManagementPlaneRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMessageMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ManagementPlaneRequestValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ManagementPlaneRequestValidationError{
					field:  "MessageMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessageMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ManagementPlaneRequestValidationError{
				field:  "MessageMeta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Request.(type) {
	case *ManagementPlaneRequest_StatusRequest:
		if v == nil {
			err := ManagementPlaneRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStatusRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "StatusRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "StatusRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStatusRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManagementPlaneRequestValidationError{
					field:  "StatusRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ManagementPlaneRequest_HealthRequest:
		if v == nil {
			err := ManagementPlaneRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHealthRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "HealthRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "HealthRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHealthRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManagementPlaneRequestValidationError{
					field:  "HealthRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ManagementPlaneRequest_ConfigApplyRequest:
		if v == nil {
			err := ManagementPlaneRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConfigApplyRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "ConfigApplyRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "ConfigApplyRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConfigApplyRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManagementPlaneRequestValidationError{
					field:  "ConfigApplyRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ManagementPlaneRequest_ConfigUploadRequest:
		if v == nil {
			err := ManagementPlaneRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConfigUploadRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "ConfigUploadRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "ConfigUploadRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConfigUploadRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManagementPlaneRequestValidationError{
					field:  "ConfigUploadRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ManagementPlaneRequest_ActionRequest:
		if v == nil {
			err := ManagementPlaneRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetActionRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "ActionRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "ActionRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManagementPlaneRequestValidationError{
					field:  "ActionRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ManagementPlaneRequest_CommandStatusRequest:
		if v == nil {
			err := ManagementPlaneRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCommandStatusRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "CommandStatusRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ManagementPlaneRequestValidationError{
						field:  "CommandStatusRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCommandStatusRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ManagementPlaneRequestValidationError{
					field:  "CommandStatusRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ManagementPlaneRequestMultiError(errors)
	}

	return nil
}

// ManagementPlaneRequestMultiError is an error wrapping multiple validation
// errors returned by ManagementPlaneRequest.ValidateAll() if the designated
// constraints aren't met.
type ManagementPlaneRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManagementPlaneRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManagementPlaneRequestMultiError) AllErrors() []error { return m }

// ManagementPlaneRequestValidationError is the validation error returned by
// ManagementPlaneRequest.Validate if the designated constraints aren't met.
type ManagementPlaneRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManagementPlaneRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManagementPlaneRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManagementPlaneRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManagementPlaneRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManagementPlaneRequestValidationError) ErrorName() string {
	return "ManagementPlaneRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ManagementPlaneRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManagementPlaneRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManagementPlaneRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManagementPlaneRequestValidationError{}

// Validate checks the field values on StatusRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatusRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatusRequestMultiError, or
// nil if none found.
func (m *StatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StatusRequestMultiError(errors)
	}

	return nil
}

// StatusRequestMultiError is an error wrapping multiple validation errors
// returned by StatusRequest.ValidateAll() if the designated constraints
// aren't met.
type StatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusRequestMultiError) AllErrors() []error { return m }

// StatusRequestValidationError is the validation error returned by
// StatusRequest.Validate if the designated constraints aren't met.
type StatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusRequestValidationError) ErrorName() string { return "StatusRequestValidationError" }

// Error satisfies the builtin error interface
func (e StatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusRequestValidationError{}

// Validate checks the field values on HealthRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthRequestMultiError, or
// nil if none found.
func (m *HealthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HealthRequestMultiError(errors)
	}

	return nil
}

// HealthRequestMultiError is an error wrapping multiple validation errors
// returned by HealthRequest.ValidateAll() if the designated constraints
// aren't met.
type HealthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthRequestMultiError) AllErrors() []error { return m }

// HealthRequestValidationError is the validation error returned by
// HealthRequest.Validate if the designated constraints aren't met.
type HealthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthRequestValidationError) ErrorName() string { return "HealthRequestValidationError" }

// Error satisfies the builtin error interface
func (e HealthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthRequestValidationError{}

// Validate checks the field values on ConfigApplyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigApplyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigApplyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigApplyRequestMultiError, or nil if none found.
func (m *ConfigApplyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigApplyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOverview()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigApplyRequestValidationError{
					field:  "Overview",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigApplyRequestValidationError{
					field:  "Overview",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverview()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigApplyRequestValidationError{
				field:  "Overview",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigApplyRequestMultiError(errors)
	}

	return nil
}

// ConfigApplyRequestMultiError is an error wrapping multiple validation errors
// returned by ConfigApplyRequest.ValidateAll() if the designated constraints
// aren't met.
type ConfigApplyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigApplyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigApplyRequestMultiError) AllErrors() []error { return m }

// ConfigApplyRequestValidationError is the validation error returned by
// ConfigApplyRequest.Validate if the designated constraints aren't met.
type ConfigApplyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigApplyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigApplyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigApplyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigApplyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigApplyRequestValidationError) ErrorName() string {
	return "ConfigApplyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigApplyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigApplyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigApplyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigApplyRequestValidationError{}

// Validate checks the field values on ConfigUploadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigUploadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigUploadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigUploadRequestMultiError, or nil if none found.
func (m *ConfigUploadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigUploadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOverview()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigUploadRequestValidationError{
					field:  "Overview",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigUploadRequestValidationError{
					field:  "Overview",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOverview()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigUploadRequestValidationError{
				field:  "Overview",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigUploadRequestMultiError(errors)
	}

	return nil
}

// ConfigUploadRequestMultiError is an error wrapping multiple validation
// errors returned by ConfigUploadRequest.ValidateAll() if the designated
// constraints aren't met.
type ConfigUploadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigUploadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigUploadRequestMultiError) AllErrors() []error { return m }

// ConfigUploadRequestValidationError is the validation error returned by
// ConfigUploadRequest.Validate if the designated constraints aren't met.
type ConfigUploadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigUploadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigUploadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigUploadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigUploadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigUploadRequestValidationError) ErrorName() string {
	return "ConfigUploadRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigUploadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigUploadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigUploadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigUploadRequestValidationError{}

// Validate checks the field values on APIActionRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *APIActionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on APIActionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// APIActionRequestMultiError, or nil if none found.
func (m *APIActionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *APIActionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	switch v := m.Action.(type) {
	case *APIActionRequest_NginxPlusAction:
		if v == nil {
			err := APIActionRequestValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNginxPlusAction()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, APIActionRequestValidationError{
						field:  "NginxPlusAction",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, APIActionRequestValidationError{
						field:  "NginxPlusAction",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNginxPlusAction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return APIActionRequestValidationError{
					field:  "NginxPlusAction",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return APIActionRequestMultiError(errors)
	}

	return nil
}

// APIActionRequestMultiError is an error wrapping multiple validation errors
// returned by APIActionRequest.ValidateAll() if the designated constraints
// aren't met.
type APIActionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APIActionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APIActionRequestMultiError) AllErrors() []error { return m }

// APIActionRequestValidationError is the validation error returned by
// APIActionRequest.Validate if the designated constraints aren't met.
type APIActionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APIActionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APIActionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APIActionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APIActionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APIActionRequestValidationError) ErrorName() string { return "APIActionRequestValidationError" }

// Error satisfies the builtin error interface
func (e APIActionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPIActionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APIActionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APIActionRequestValidationError{}

// Validate checks the field values on NGINXPlusAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NGINXPlusAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NGINXPlusAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NGINXPlusActionMultiError, or nil if none found.
func (m *NGINXPlusAction) ValidateAll() error {
	return m.validate(true)
}

func (m *NGINXPlusAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Action.(type) {
	case *NGINXPlusAction_UpdateHttpUpstreamServers:
		if v == nil {
			err := NGINXPlusActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpdateHttpUpstreamServers()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "UpdateHttpUpstreamServers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "UpdateHttpUpstreamServers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdateHttpUpstreamServers()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NGINXPlusActionValidationError{
					field:  "UpdateHttpUpstreamServers",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *NGINXPlusAction_GetHttpUpstreamServers:
		if v == nil {
			err := NGINXPlusActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetHttpUpstreamServers()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "GetHttpUpstreamServers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "GetHttpUpstreamServers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetHttpUpstreamServers()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NGINXPlusActionValidationError{
					field:  "GetHttpUpstreamServers",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *NGINXPlusAction_UpdateStreamServers:
		if v == nil {
			err := NGINXPlusActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpdateStreamServers()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "UpdateStreamServers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "UpdateStreamServers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdateStreamServers()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NGINXPlusActionValidationError{
					field:  "UpdateStreamServers",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *NGINXPlusAction_GetUpstreams:
		if v == nil {
			err := NGINXPlusActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetUpstreams()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "GetUpstreams",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "GetUpstreams",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetUpstreams()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NGINXPlusActionValidationError{
					field:  "GetUpstreams",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *NGINXPlusAction_GetStreamUpstreams:
		if v == nil {
			err := NGINXPlusActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetStreamUpstreams()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "GetStreamUpstreams",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NGINXPlusActionValidationError{
						field:  "GetStreamUpstreams",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetStreamUpstreams()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NGINXPlusActionValidationError{
					field:  "GetStreamUpstreams",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return NGINXPlusActionMultiError(errors)
	}

	return nil
}

// NGINXPlusActionMultiError is an error wrapping multiple validation errors
// returned by NGINXPlusAction.ValidateAll() if the designated constraints
// aren't met.
type NGINXPlusActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NGINXPlusActionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NGINXPlusActionMultiError) AllErrors() []error { return m }

// NGINXPlusActionValidationError is the validation error returned by
// NGINXPlusAction.Validate if the designated constraints aren't met.
type NGINXPlusActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NGINXPlusActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NGINXPlusActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NGINXPlusActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NGINXPlusActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NGINXPlusActionValidationError) ErrorName() string { return "NGINXPlusActionValidationError" }

// Error satisfies the builtin error interface
func (e NGINXPlusActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNGINXPlusAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NGINXPlusActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NGINXPlusActionValidationError{}

// Validate checks the field values on UpdateHTTPUpstreamServers with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateHTTPUpstreamServers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateHTTPUpstreamServers with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateHTTPUpstreamServersMultiError, or nil if none found.
func (m *UpdateHTTPUpstreamServers) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateHTTPUpstreamServers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HttpUpstreamName

	for idx, item := range m.GetServers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateHTTPUpstreamServersValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateHTTPUpstreamServersValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateHTTPUpstreamServersValidationError{
					field:  fmt.Sprintf("Servers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateHTTPUpstreamServersMultiError(errors)
	}

	return nil
}

// UpdateHTTPUpstreamServersMultiError is an error wrapping multiple validation
// errors returned by UpdateHTTPUpstreamServers.ValidateAll() if the
// designated constraints aren't met.
type UpdateHTTPUpstreamServersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateHTTPUpstreamServersMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateHTTPUpstreamServersMultiError) AllErrors() []error { return m }

// UpdateHTTPUpstreamServersValidationError is the validation error returned by
// UpdateHTTPUpstreamServers.Validate if the designated constraints aren't met.
type UpdateHTTPUpstreamServersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateHTTPUpstreamServersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateHTTPUpstreamServersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateHTTPUpstreamServersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateHTTPUpstreamServersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateHTTPUpstreamServersValidationError) ErrorName() string {
	return "UpdateHTTPUpstreamServersValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateHTTPUpstreamServersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateHTTPUpstreamServers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateHTTPUpstreamServersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateHTTPUpstreamServersValidationError{}

// Validate checks the field values on GetHTTPUpstreamServers with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetHTTPUpstreamServers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHTTPUpstreamServers with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHTTPUpstreamServersMultiError, or nil if none found.
func (m *GetHTTPUpstreamServers) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHTTPUpstreamServers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HttpUpstreamName

	if len(errors) > 0 {
		return GetHTTPUpstreamServersMultiError(errors)
	}

	return nil
}

// GetHTTPUpstreamServersMultiError is an error wrapping multiple validation
// errors returned by GetHTTPUpstreamServers.ValidateAll() if the designated
// constraints aren't met.
type GetHTTPUpstreamServersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHTTPUpstreamServersMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHTTPUpstreamServersMultiError) AllErrors() []error { return m }

// GetHTTPUpstreamServersValidationError is the validation error returned by
// GetHTTPUpstreamServers.Validate if the designated constraints aren't met.
type GetHTTPUpstreamServersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHTTPUpstreamServersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHTTPUpstreamServersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHTTPUpstreamServersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHTTPUpstreamServersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHTTPUpstreamServersValidationError) ErrorName() string {
	return "GetHTTPUpstreamServersValidationError"
}

// Error satisfies the builtin error interface
func (e GetHTTPUpstreamServersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHTTPUpstreamServers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHTTPUpstreamServersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHTTPUpstreamServersValidationError{}

// Validate checks the field values on UpdateStreamServers with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateStreamServers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateStreamServers with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateStreamServersMultiError, or nil if none found.
func (m *UpdateStreamServers) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateStreamServers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UpstreamStreamName

	for idx, item := range m.GetServers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateStreamServersValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateStreamServersValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateStreamServersValidationError{
					field:  fmt.Sprintf("Servers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateStreamServersMultiError(errors)
	}

	return nil
}

// UpdateStreamServersMultiError is an error wrapping multiple validation
// errors returned by UpdateStreamServers.ValidateAll() if the designated
// constraints aren't met.
type UpdateStreamServersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStreamServersMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStreamServersMultiError) AllErrors() []error { return m }

// UpdateStreamServersValidationError is the validation error returned by
// UpdateStreamServers.Validate if the designated constraints aren't met.
type UpdateStreamServersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStreamServersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStreamServersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStreamServersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStreamServersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStreamServersValidationError) ErrorName() string {
	return "UpdateStreamServersValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStreamServersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStreamServers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStreamServersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStreamServersValidationError{}

// Validate checks the field values on GetUpstreams with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUpstreams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUpstreams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUpstreamsMultiError, or
// nil if none found.
func (m *GetUpstreams) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUpstreams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetUpstreamsMultiError(errors)
	}

	return nil
}

// GetUpstreamsMultiError is an error wrapping multiple validation errors
// returned by GetUpstreams.ValidateAll() if the designated constraints aren't met.
type GetUpstreamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUpstreamsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUpstreamsMultiError) AllErrors() []error { return m }

// GetUpstreamsValidationError is the validation error returned by
// GetUpstreams.Validate if the designated constraints aren't met.
type GetUpstreamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUpstreamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUpstreamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUpstreamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUpstreamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUpstreamsValidationError) ErrorName() string { return "GetUpstreamsValidationError" }

// Error satisfies the builtin error interface
func (e GetUpstreamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUpstreams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUpstreamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUpstreamsValidationError{}

// Validate checks the field values on GetStreamUpstreams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetStreamUpstreams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStreamUpstreams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStreamUpstreamsMultiError, or nil if none found.
func (m *GetStreamUpstreams) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStreamUpstreams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetStreamUpstreamsMultiError(errors)
	}

	return nil
}

// GetStreamUpstreamsMultiError is an error wrapping multiple validation errors
// returned by GetStreamUpstreams.ValidateAll() if the designated constraints
// aren't met.
type GetStreamUpstreamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStreamUpstreamsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStreamUpstreamsMultiError) AllErrors() []error { return m }

// GetStreamUpstreamsValidationError is the validation error returned by
// GetStreamUpstreams.Validate if the designated constraints aren't met.
type GetStreamUpstreamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStreamUpstreamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStreamUpstreamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStreamUpstreamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStreamUpstreamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStreamUpstreamsValidationError) ErrorName() string {
	return "GetStreamUpstreamsValidationError"
}

// Error satisfies the builtin error interface
func (e GetStreamUpstreamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStreamUpstreams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStreamUpstreamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStreamUpstreamsValidationError{}

// Validate checks the field values on CommandStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommandStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommandStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommandStatusRequestMultiError, or nil if none found.
func (m *CommandStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CommandStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CommandStatusRequestMultiError(errors)
	}

	return nil
}

// CommandStatusRequestMultiError is an error wrapping multiple validation
// errors returned by CommandStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type CommandStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommandStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommandStatusRequestMultiError) AllErrors() []error { return m }

// CommandStatusRequestValidationError is the validation error returned by
// CommandStatusRequest.Validate if the designated constraints aren't met.
type CommandStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommandStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommandStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommandStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommandStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommandStatusRequestValidationError) ErrorName() string {
	return "CommandStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CommandStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommandStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommandStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommandStatusRequestValidationError{}

// Validate checks the field values on Instance with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Instance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Instance with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceMultiError, or nil
// if none found.
func (m *Instance) ValidateAll() error {
	return m.validate(true)
}

func (m *Instance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstanceMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "InstanceMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "InstanceMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstanceMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceValidationError{
				field:  "InstanceMeta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInstanceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "InstanceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "InstanceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstanceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceValidationError{
				field:  "InstanceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInstanceRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "InstanceRuntime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "InstanceRuntime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstanceRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceValidationError{
				field:  "InstanceRuntime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstanceMultiError(errors)
	}

	return nil
}

// InstanceMultiError is an error wrapping multiple validation errors returned
// by Instance.ValidateAll() if the designated constraints aren't met.
type InstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceMultiError) AllErrors() []error { return m }

// InstanceValidationError is the validation error returned by
// Instance.Validate if the designated constraints aren't met.
type InstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceValidationError) ErrorName() string { return "InstanceValidationError" }

// Error satisfies the builtin error interface
func (e InstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceValidationError{}

// Validate checks the field values on InstanceMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceMetaMultiError, or
// nil if none found.
func (m *InstanceMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for InstanceType

	// no validation rules for Version

	if len(errors) > 0 {
		return InstanceMetaMultiError(errors)
	}

	return nil
}

// InstanceMetaMultiError is an error wrapping multiple validation errors
// returned by InstanceMeta.ValidateAll() if the designated constraints aren't met.
type InstanceMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceMetaMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceMetaMultiError) AllErrors() []error { return m }

// InstanceMetaValidationError is the validation error returned by
// InstanceMeta.Validate if the designated constraints aren't met.
type InstanceMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceMetaValidationError) ErrorName() string { return "InstanceMetaValidationError" }

// Error satisfies the builtin error interface
func (e InstanceMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceMetaValidationError{}

// Validate checks the field values on InstanceConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceConfigMultiError,
// or nil if none found.
func (m *InstanceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceConfigValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceConfigValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceConfigValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Config.(type) {
	case *InstanceConfig_AgentConfig:
		if v == nil {
			err := InstanceConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAgentConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceConfigValidationError{
						field:  "AgentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceConfigValidationError{
						field:  "AgentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAgentConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceConfigValidationError{
					field:  "AgentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return InstanceConfigMultiError(errors)
	}

	return nil
}

// InstanceConfigMultiError is an error wrapping multiple validation errors
// returned by InstanceConfig.ValidateAll() if the designated constraints
// aren't met.
type InstanceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceConfigMultiError) AllErrors() []error { return m }

// InstanceConfigValidationError is the validation error returned by
// InstanceConfig.Validate if the designated constraints aren't met.
type InstanceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceConfigValidationError) ErrorName() string { return "InstanceConfigValidationError" }

// Error satisfies the builtin error interface
func (e InstanceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceConfigValidationError{}

// Validate checks the field values on InstanceRuntime with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InstanceRuntime) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceRuntime with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceRuntimeMultiError, or nil if none found.
func (m *InstanceRuntime) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceRuntime) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProcessId

	// no validation rules for BinaryPath

	// no validation rules for ConfigPath

	for idx, item := range m.GetInstanceChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceRuntimeValidationError{
						field:  fmt.Sprintf("InstanceChildren[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceRuntimeValidationError{
						field:  fmt.Sprintf("InstanceChildren[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceRuntimeValidationError{
					field:  fmt.Sprintf("InstanceChildren[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Details.(type) {
	case *InstanceRuntime_NginxRuntimeInfo:
		if v == nil {
			err := InstanceRuntimeValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNginxRuntimeInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceRuntimeValidationError{
						field:  "NginxRuntimeInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceRuntimeValidationError{
						field:  "NginxRuntimeInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNginxRuntimeInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceRuntimeValidationError{
					field:  "NginxRuntimeInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *InstanceRuntime_NginxPlusRuntimeInfo:
		if v == nil {
			err := InstanceRuntimeValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNginxPlusRuntimeInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceRuntimeValidationError{
						field:  "NginxPlusRuntimeInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceRuntimeValidationError{
						field:  "NginxPlusRuntimeInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNginxPlusRuntimeInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceRuntimeValidationError{
					field:  "NginxPlusRuntimeInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *InstanceRuntime_NginxAppProtectRuntimeInfo:
		if v == nil {
			err := InstanceRuntimeValidationError{
				field:  "Details",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNginxAppProtectRuntimeInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceRuntimeValidationError{
						field:  "NginxAppProtectRuntimeInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceRuntimeValidationError{
						field:  "NginxAppProtectRuntimeInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNginxAppProtectRuntimeInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceRuntimeValidationError{
					field:  "NginxAppProtectRuntimeInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return InstanceRuntimeMultiError(errors)
	}

	return nil
}

// InstanceRuntimeMultiError is an error wrapping multiple validation errors
// returned by InstanceRuntime.ValidateAll() if the designated constraints
// aren't met.
type InstanceRuntimeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceRuntimeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceRuntimeMultiError) AllErrors() []error { return m }

// InstanceRuntimeValidationError is the validation error returned by
// InstanceRuntime.Validate if the designated constraints aren't met.
type InstanceRuntimeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceRuntimeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceRuntimeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceRuntimeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceRuntimeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceRuntimeValidationError) ErrorName() string { return "InstanceRuntimeValidationError" }

// Error satisfies the builtin error interface
func (e InstanceRuntimeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceRuntime.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceRuntimeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceRuntimeValidationError{}

// Validate checks the field values on InstanceChild with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceChild) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceChild with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceChildMultiError, or
// nil if none found.
func (m *InstanceChild) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceChild) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProcessId

	if len(errors) > 0 {
		return InstanceChildMultiError(errors)
	}

	return nil
}

// InstanceChildMultiError is an error wrapping multiple validation errors
// returned by InstanceChild.ValidateAll() if the designated constraints
// aren't met.
type InstanceChildMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceChildMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceChildMultiError) AllErrors() []error { return m }

// InstanceChildValidationError is the validation error returned by
// InstanceChild.Validate if the designated constraints aren't met.
type InstanceChildValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceChildValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceChildValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceChildValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceChildValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceChildValidationError) ErrorName() string { return "InstanceChildValidationError" }

// Error satisfies the builtin error interface
func (e InstanceChildValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceChild.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceChildValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceChildValidationError{}

// Validate checks the field values on NGINXRuntimeInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NGINXRuntimeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NGINXRuntimeInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NGINXRuntimeInfoMultiError, or nil if none found.
func (m *NGINXRuntimeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NGINXRuntimeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStubStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NGINXRuntimeInfoValidationError{
					field:  "StubStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NGINXRuntimeInfoValidationError{
					field:  "StubStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStubStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NGINXRuntimeInfoValidationError{
				field:  "StubStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NGINXRuntimeInfoMultiError(errors)
	}

	return nil
}

// NGINXRuntimeInfoMultiError is an error wrapping multiple validation errors
// returned by NGINXRuntimeInfo.ValidateAll() if the designated constraints
// aren't met.
type NGINXRuntimeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NGINXRuntimeInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NGINXRuntimeInfoMultiError) AllErrors() []error { return m }

// NGINXRuntimeInfoValidationError is the validation error returned by
// NGINXRuntimeInfo.Validate if the designated constraints aren't met.
type NGINXRuntimeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NGINXRuntimeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NGINXRuntimeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NGINXRuntimeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NGINXRuntimeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NGINXRuntimeInfoValidationError) ErrorName() string { return "NGINXRuntimeInfoValidationError" }

// Error satisfies the builtin error interface
func (e NGINXRuntimeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNGINXRuntimeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NGINXRuntimeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NGINXRuntimeInfoValidationError{}

// Validate checks the field values on NGINXPlusRuntimeInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NGINXPlusRuntimeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NGINXPlusRuntimeInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NGINXPlusRuntimeInfoMultiError, or nil if none found.
func (m *NGINXPlusRuntimeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NGINXPlusRuntimeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStubStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NGINXPlusRuntimeInfoValidationError{
					field:  "StubStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NGINXPlusRuntimeInfoValidationError{
					field:  "StubStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStubStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NGINXPlusRuntimeInfoValidationError{
				field:  "StubStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlusApi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NGINXPlusRuntimeInfoValidationError{
					field:  "PlusApi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NGINXPlusRuntimeInfoValidationError{
					field:  "PlusApi",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlusApi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NGINXPlusRuntimeInfoValidationError{
				field:  "PlusApi",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NGINXPlusRuntimeInfoMultiError(errors)
	}

	return nil
}

// NGINXPlusRuntimeInfoMultiError is an error wrapping multiple validation
// errors returned by NGINXPlusRuntimeInfo.ValidateAll() if the designated
// constraints aren't met.
type NGINXPlusRuntimeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NGINXPlusRuntimeInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NGINXPlusRuntimeInfoMultiError) AllErrors() []error { return m }

// NGINXPlusRuntimeInfoValidationError is the validation error returned by
// NGINXPlusRuntimeInfo.Validate if the designated constraints aren't met.
type NGINXPlusRuntimeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NGINXPlusRuntimeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NGINXPlusRuntimeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NGINXPlusRuntimeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NGINXPlusRuntimeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NGINXPlusRuntimeInfoValidationError) ErrorName() string {
	return "NGINXPlusRuntimeInfoValidationError"
}

// Error satisfies the builtin error interface
func (e NGINXPlusRuntimeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNGINXPlusRuntimeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NGINXPlusRuntimeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NGINXPlusRuntimeInfoValidationError{}

// Validate checks the field values on APIDetails with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *APIDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on APIDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in APIDetailsMultiError, or
// nil if none found.
func (m *APIDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *APIDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Location

	// no validation rules for Listen

	// no validation rules for Ca

	if len(errors) > 0 {
		return APIDetailsMultiError(errors)
	}

	return nil
}

// APIDetailsMultiError is an error wrapping multiple validation errors
// returned by APIDetails.ValidateAll() if the designated constraints aren't met.
type APIDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APIDetailsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APIDetailsMultiError) AllErrors() []error { return m }

// APIDetailsValidationError is the validation error returned by
// APIDetails.Validate if the designated constraints aren't met.
type APIDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APIDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APIDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APIDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APIDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APIDetailsValidationError) ErrorName() string { return "APIDetailsValidationError" }

// Error satisfies the builtin error interface
func (e APIDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPIDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APIDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APIDetailsValidationError{}

// Validate checks the field values on NGINXAppProtectRuntimeInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NGINXAppProtectRuntimeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NGINXAppProtectRuntimeInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NGINXAppProtectRuntimeInfoMultiError, or nil if none found.
func (m *NGINXAppProtectRuntimeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NGINXAppProtectRuntimeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Release

	// no validation rules for AttackSignatureVersion

	// no validation rules for ThreatCampaignVersion

	// no validation rules for EnforcerEngineVersion

	if len(errors) > 0 {
		return NGINXAppProtectRuntimeInfoMultiError(errors)
	}

	return nil
}

// NGINXAppProtectRuntimeInfoMultiError is an error wrapping multiple
// validation errors returned by NGINXAppProtectRuntimeInfo.ValidateAll() if
// the designated constraints aren't met.
type NGINXAppProtectRuntimeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NGINXAppProtectRuntimeInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NGINXAppProtectRuntimeInfoMultiError) AllErrors() []error { return m }

// NGINXAppProtectRuntimeInfoValidationError is the validation error returned
// by NGINXAppProtectRuntimeInfo.Validate if the designated constraints aren't met.
type NGINXAppProtectRuntimeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NGINXAppProtectRuntimeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NGINXAppProtectRuntimeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NGINXAppProtectRuntimeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NGINXAppProtectRuntimeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NGINXAppProtectRuntimeInfoValidationError) ErrorName() string {
	return "NGINXAppProtectRuntimeInfoValidationError"
}

// Error satisfies the builtin error interface
func (e NGINXAppProtectRuntimeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNGINXAppProtectRuntimeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NGINXAppProtectRuntimeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NGINXAppProtectRuntimeInfoValidationError{}

// Validate checks the field values on InstanceAction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceActionMultiError,
// or nil if none found.
func (m *InstanceAction) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return InstanceActionMultiError(errors)
	}

	return nil
}

// InstanceActionMultiError is an error wrapping multiple validation errors
// returned by InstanceAction.ValidateAll() if the designated constraints
// aren't met.
type InstanceActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceActionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceActionMultiError) AllErrors() []error { return m }

// InstanceActionValidationError is the validation error returned by
// InstanceAction.Validate if the designated constraints aren't met.
type InstanceActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceActionValidationError) ErrorName() string { return "InstanceActionValidationError" }

// Error satisfies the builtin error interface
func (e InstanceActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceActionValidationError{}

// Validate checks the field values on AgentConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AgentConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AgentConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AgentConfigMultiError, or
// nil if none found.
func (m *AgentConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AgentConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AgentConfigValidationError{
					field:  "Command",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AgentConfigValidationError{
					field:  "Command",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AgentConfigValidationError{
				field:  "Command",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetrics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AgentConfigValidationError{
					field:  "Metrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AgentConfigValidationError{
					field:  "Metrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetrics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AgentConfigValidationError{
				field:  "Metrics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AgentConfigValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AgentConfigValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AgentConfigValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AgentConfigValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AgentConfigValidationError{
						field:  fmt.Sprintf("Labels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AgentConfigValidationError{
					field:  fmt.Sprintf("Labels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MessageBufferSize

	if all {
		switch v := interface{}(m.GetAuxiliaryCommand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AgentConfigValidationError{
					field:  "AuxiliaryCommand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AgentConfigValidationError{
					field:  "AuxiliaryCommand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuxiliaryCommand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AgentConfigValidationError{
				field:  "AuxiliaryCommand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AgentConfigMultiError(errors)
	}

	return nil
}

// AgentConfigMultiError is an error wrapping multiple validation errors
// returned by AgentConfig.ValidateAll() if the designated constraints aren't met.
type AgentConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AgentConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AgentConfigMultiError) AllErrors() []error { return m }

// AgentConfigValidationError is the validation error returned by
// AgentConfig.Validate if the designated constraints aren't met.
type AgentConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AgentConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AgentConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AgentConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AgentConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AgentConfigValidationError) ErrorName() string { return "AgentConfigValidationError" }

// Error satisfies the builtin error interface
func (e AgentConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAgentConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AgentConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AgentConfigValidationError{}

// Validate checks the field values on CommandServer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommandServer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommandServer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommandServerMultiError, or
// nil if none found.
func (m *CommandServer) ValidateAll() error {
	return m.validate(true)
}

func (m *CommandServer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetServer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommandServerValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommandServerValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommandServerValidationError{
				field:  "Server",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommandServerValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommandServerValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommandServerValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTls()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommandServerValidationError{
					field:  "Tls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommandServerValidationError{
					field:  "Tls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTls()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommandServerValidationError{
				field:  "Tls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommandServerMultiError(errors)
	}

	return nil
}

// CommandServerMultiError is an error wrapping multiple validation errors
// returned by CommandServer.ValidateAll() if the designated constraints
// aren't met.
type CommandServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommandServerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommandServerMultiError) AllErrors() []error { return m }

// CommandServerValidationError is the validation error returned by
// CommandServer.Validate if the designated constraints aren't met.
type CommandServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommandServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommandServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommandServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommandServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommandServerValidationError) ErrorName() string { return "CommandServerValidationError" }

// Error satisfies the builtin error interface
func (e CommandServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommandServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommandServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommandServerValidationError{}

// Validate checks the field values on AuxiliaryCommandServer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuxiliaryCommandServer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuxiliaryCommandServer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuxiliaryCommandServerMultiError, or nil if none found.
func (m *AuxiliaryCommandServer) ValidateAll() error {
	return m.validate(true)
}

func (m *AuxiliaryCommandServer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetServer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuxiliaryCommandServerValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuxiliaryCommandServerValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuxiliaryCommandServerValidationError{
				field:  "Server",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuxiliaryCommandServerValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuxiliaryCommandServerValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuxiliaryCommandServerValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTls()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuxiliaryCommandServerValidationError{
					field:  "Tls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuxiliaryCommandServerValidationError{
					field:  "Tls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTls()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuxiliaryCommandServerValidationError{
				field:  "Tls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuxiliaryCommandServerMultiError(errors)
	}

	return nil
}

// AuxiliaryCommandServerMultiError is an error wrapping multiple validation
// errors returned by AuxiliaryCommandServer.ValidateAll() if the designated
// constraints aren't met.
type AuxiliaryCommandServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuxiliaryCommandServerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuxiliaryCommandServerMultiError) AllErrors() []error { return m }

// AuxiliaryCommandServerValidationError is the validation error returned by
// AuxiliaryCommandServer.Validate if the designated constraints aren't met.
type AuxiliaryCommandServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuxiliaryCommandServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuxiliaryCommandServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuxiliaryCommandServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuxiliaryCommandServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuxiliaryCommandServerValidationError) ErrorName() string {
	return "AuxiliaryCommandServerValidationError"
}

// Error satisfies the builtin error interface
func (e AuxiliaryCommandServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuxiliaryCommandServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuxiliaryCommandServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuxiliaryCommandServerValidationError{}

// Validate checks the field values on MetricsServer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricsServer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsServer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetricsServerMultiError, or
// nil if none found.
func (m *MetricsServer) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsServer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MetricsServerMultiError(errors)
	}

	return nil
}

// MetricsServerMultiError is an error wrapping multiple validation errors
// returned by MetricsServer.ValidateAll() if the designated constraints
// aren't met.
type MetricsServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsServerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsServerMultiError) AllErrors() []error { return m }

// MetricsServerValidationError is the validation error returned by
// MetricsServer.Validate if the designated constraints aren't met.
type MetricsServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsServerValidationError) ErrorName() string { return "MetricsServerValidationError" }

// Error satisfies the builtin error interface
func (e MetricsServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsServerValidationError{}

// Validate checks the field values on FileServer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileServer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileServer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileServerMultiError, or
// nil if none found.
func (m *FileServer) ValidateAll() error {
	return m.validate(true)
}

func (m *FileServer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FileServerMultiError(errors)
	}

	return nil
}

// FileServerMultiError is an error wrapping multiple validation errors
// returned by FileServer.ValidateAll() if the designated constraints aren't met.
type FileServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileServerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileServerMultiError) AllErrors() []error { return m }

// FileServerValidationError is the validation error returned by
// FileServer.Validate if the designated constraints aren't met.
type FileServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileServerValidationError) ErrorName() string { return "FileServerValidationError" }

// Error satisfies the builtin error interface
func (e FileServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileServerValidationError{}
